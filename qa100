question,contexts,ground_truth,evolution_type,metadata,episode_done,answer,answer_llama_pars
How can deep linking be properly implemented in an app to redirect users after payment via third-party apps?,"['\nHandling deeplinks in your app\n\n238\n\nTo redirect a user to your app after payment via third-party apps (the Faster Payments System (SBP), SberPay and others), you need to properly implement deep linking in your app. Specify the intent-filter with the scheme in AndroidManifest.xml:\n\n<activity\n\nandroid:name="".sample.MainActivity"">\n\n<intent-filter>\n\n<action android:name=""android.intent.action.MAIN"" />\n\n<category android:name=""android.intent.category.LAUNCHER"" />\n\n</intent-filter>\n\n<intent-filter>\n\n<action android:name=""android.intent.action.VIEW"" />\n\n<category android:name=""android.intent.category.DEFAULT"" />\n\n<category android:name=""android.intent.category.BROWSABLE""\n\n/>\n\n<data android:scheme=""yourappscheme"" />\n\n</intent-filter>\n\n</activity>\n\nwhere ""yourappscheme"" — your deeplink scheme, it can be changed to another one.\n\nThis scheme must match the deeplinkScheme parameter passed to init().\n\nExporting a project with an enabled plugin\n\nTo make a plugin available in your Godot project, it must be enabled in the export settings.\n\n239\n\nAfter all the settings are set, you can use the plugin in your project.\n\nHow to initialize the library\n\nYou must initialize the library to call its method. To do this, call the init() method:\n\nif Engine.has_singleton(""RustoreBilling""):\n\nbilling = Engine.get_singleton(""RustoreBilling"")\n\nbilling.init(""123456"", ""yourappscheme://iamback"")\n\nbilling.rustore_is_available.connect(_on_availability)\n\nbilling.rustore_purchase_product.connect(_on_purchase)\n\nbilling.rustore_delete_purchase.connect(_on_delete)\n\nbilling.rustore_confirm_purchase.connect(_on_confirm)\n\nbilling.rustore_get_purchases.connect(_on_get_purchases)\n\nbilling.rustore_get_purchase.connect(_on_get_purchase)\n\nbilling.rustore_get_products.connect(_on_get_products)\n\n123456 — application code from RuStore Console (example:\n\nhttps://console.rustore.ru/apps/123456).\n\nyourappscheme://iamback — deeplink scheme required to return to your app page after payment through a third-party application (for example, SberPay or SBP). The SDK generates its own host for this scheme.\n\nMake sure that the deeplink scheme passed to deeplinkScheme matches the scheme specified in AndroidManifest.xml in the ""Deeplink Processing"" section.\n\nAfter the plugin is initialized, it will be connected to all available signals.\n\n240\n\nPayment functions availability\n\nTo check whether your app supports payment functions, the following conditions should be met:\n\n1. The RuStore app must be installed on the user\'s device. 2. Your RuStore app should support the payment processing function. 3. Your app user must be authorized on the RuStore. 4. The user and the application must not be blocked on the RuStore. 5. The RuStore Console shopping option must be enabled for the application.\n\nIf all conditions are met, the isAvailable() method returns true.\n\nfunc _availability():\n\nif billing != null: billing.isAvailable()\n\nfunc _on_availability(data: Dictionary):\n\nif data[\'status\'] == \'success\': print(\'success\') print(data[\'result\']) elif data[\'status\'] == \'failure\': print(\'failure\') print(data[\'message\'])\n\nThe _on_availability(data: Dictionary) method is a rustore_is_available signal handler that receives a message about RuStore availability.\n\nThe data[\'status\'] key stores the request execution status. Possible values\n\nsuccess —request successfully completed. In this case, the data[\'result\'] key will return\n\ntrue if RuStore is available and false if it is not available. ● failure — request error occurred. In the key data[\'message\']\n\nGetting the product list\n\nUse the getProducts method to get a list of products:\n\nfunc _get_products():\n\nif billing != null:\n\nbilling.getProducts']","To properly implement deep linking in an app to redirect users after payment via third-party apps, you need to specify the intent-filter with the scheme in AndroidManifest.xml. The scheme must match the deeplinkScheme parameter passed to init(). After all settings are set, you can use the plugin in your project by initializing the library and connecting it to all available signals.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To properly implement deep linking in an app to redirect users after payment via third-party apps, you need to follow these steps:

1. Specify the intent-filter with the scheme in the AndroidManifest.xml file:
```xml
<activity android:name="".YourBillingActivity"">
    <intent-filter>
        <action android:name=""android.intent.action.MAIN"" />
        <category android:name=""android.intent.category.LAUNCHER"" />
    </intent-filter>
    <intent-filter>
        <action android:name=""android.intent.action.VIEW"" />
        <category android:name=""android.intent.category.DEFAULT"" />
        <category android:name=""android.intent.category.BROWSABLE"" />
        <data android:scheme=""yourappscheme"" />
    </intent-filter>
</activity>
```
In the above code snippet, replace ""yourappscheme"" with your deeplink scheme. This scheme must match the deeplinkScheme parameter passed to init().

2. Add the following code to the Activity where you want to return after making the payment (your store page):
```java
public class YourBillingActivity extends AppCompatActivity {
    // Previously created with RuStoreBillingClientFactory.create();
    RuStoreBillingClient billingClient = YourDependencyInjection.getBillingClient();

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (savedInstanceState == null) {
            billingClient.onNewIntent(getIntent());
        }
    }
}
```
In this code snippet, the YourBillingActivity class extends AppCompatActivity and initializes the billingClient using YourDependencyInjection.getBillingClient(). The onCreate method checks if the savedInstanceState is null and then calls billingClient.onNewIntent(getIntent()).

By following these steps, you can properly implement deep linking in your app to redirect users after payment via third-party apps like the Faster Payments System (SBP), SberPay, and others.","To properly implement deep linking in your app to redirect users after payment via third-party apps, you need to follow these steps:

1. Specify the intent-filter with the scheme in AndroidManifest.xml:
```xml
<activity
android:name="".YourBillingActivity"">

<intent-filter>
<action android:name=""android.intent.action.MAIN"" />
<category android:name=""android.intent.category.LAUNCHER"" />
</intent-filter>

<intent-filter>
<action android:name=""android.intent.action.VIEW"" />
<category android:name=""android.intent.category.DEFAULT"" />
<category android:name=""android.intent.category.BROWSABLE"" />
<data android:scheme=""yourappscheme"" />
</intent-filter>

</activity>
```
In this code snippet, replace ""yourappscheme"" with your deeplink scheme, which must match the deeplinkScheme parameter passed to init().

2. Add the following code to the Activity you need to return to after making the payment (your store page):
```java
public class YourBillingActivity extends AppCompatActivity {

    // Previously created with RuStoreBillingClientFactory.create();
    RuStoreBillingClient billingClient = YourDependencyInjection.getBillingClient();

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (savedInstanceState == null) {
            billingClient.onNewIntent(getIntent());
        }
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        billingClient.onNewIntent(intent);
    }
}
```

3. To restore your app after deep linking, add the following to AndroidManifest.xml:
```xml
<activity android:name="".YourBillingActivity"" android:launchMode=""singleTask"" android:exported=""true"" android:screenOrientation=""portrait"" android:windowSoftInputMode=""adjustResize"">
```

By following these steps, you can properly implement deep linking in your app to redirect users after payment via third-party apps."
How can LogoConfig be used to configure the logo alignment and additional paddings in the Maps Mobile SDK?,"['""\n\n}\n\n} } }\n\nYou should also specify the dependency in the gradle file, as shown in the example.\n\nDependency injection\n\nimplementation(\'ru.rustore.geo:mapkit:x.x.x\') where x.x.x — SDK version.\n\nWe recommend using the latest SDK version. Release versions of SDK are numbered 1.0.x\n\nThe latest SDK version is available at: https://github.com/geors?tab=packages&repo_name=maps-sdk-android\n\n872\n\nHow to use Maps Mobile SDK\n\nIt is required to initialize the card global settings before using any other SDK component, the best option is in the Application class successor. The global settings object is:\n\nclass MapViewConfig(\n\nval apiKey: String, // unique key to grant access to SDK\n\n)\n\ninstall the object:\n\nMapGlobalConfig.setMapGlobalConfig(\n\nMapViewConfig(\n\napiKey = apiKey\n\n)\n\n)\n\nTo start working with SDK, a number of classes are provided that implement View in one form or another:\n\ndata class MapStartOptions(\n\nval center: LatLon, // initial map location point (only for\n\nlat, lon)\n\nval zoomLevel: Float, // initial zoom level (zoomLevel)\n\nval style: MapStyle, // map style, you can select the\n\ncorresponding enum or use your own\n\nval compassLocationMode: CompassLocationMode, // compass\n\nsetting, can be selected from the corresponding enum\n\nval logoConfig: LogoConfig // logo configuration\n\n)\n\nYou need to set the start settings as shown in the example.\n\nMapGlobalConfig.setMapStartOptions(MapStartOptions(...))\n\nLogoConfig example\n\n873\n\ndata class LogoConfig(\n\nval logoAlignment: Alignment, // Alignment: BottomRight,\n\nBottomLeft, TopRight, TopLeft\n\nval logoAdditionalPaddings: AdditionalPaddings\n\n)\n\nTo work with the SDK, a number of classes are provided that implement View in one form or another:\n\nMapView is the main view in the SDK that displays the map; - - CurrentLocationView is a button to focus the map on the current user position and follow his position;\n\nCompassView is a component that displays the direction of a physical device relative to\n\nthe north.\n\nTo display these controls, you must place them in the xml file.\n\n<FrameLayout\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.rustore.geo.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n</FrameLayout>\n\nMap example\n\n<FrameLayout\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.mail.maps.sdk.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n874\n\n</FrameLayout>\n\nThis may be enough to work with the map if other elements are not required.\n\nConrols example\n\n<FrameLayout\n\nxmlns:custom=""http://schemas.android.com/apk/res-auto""\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.rustore.geo.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n<ru.rustore.geo.views.ZoomView\n\nandroid:id=""@+id/zoomView""\n\nandroid:layout_width=""wrap_content""\n\nandroid:layout_height=""wrap_content""\n\n...\n\ncustom:mapView=""@+id/mapView"" />\n\n<ru.rustore.geo.views.CompassView\n\nandroid:layout_width=""wrap_content""']","LogoConfig in the Maps Mobile SDK can be used to configure the logo alignment and additional paddings by specifying the logoAlignment (BottomRight, BottomLeft, TopRight, TopLeft) and logoAdditionalPaddings parameters.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To configure the logo alignment and additional paddings in the Maps Mobile SDK using the LogoConfig class, you can follow these steps:

1. Create an instance of the LogoConfig class, which contains the following properties:
   - logoAlignment: This property specifies the alignment of the logo on the map and can have values of BottomRight, BottomLeft, TopRight, or TopLeft.
   - logoAdditionalPaddings: This property allows you to set additional paddings for the logo.

2. Set the desired values for the logoAlignment and logoAdditionalPaddings properties in the LogoConfig instance.

3. Include the LogoConfig instance in the MapStartOptions class when setting the start settings for the map. The LogoConfig instance will be passed as a parameter in the MapStartOptions class.

By following these steps and configuring the LogoConfig class with the desired alignment and additional paddings, you can customize the logo display on the map in the Maps Mobile SDK.","To configure the logo alignment and additional paddings in the Maps Mobile SDK using LogoConfig, you can follow these steps:

1. Create a LogoConfig object with the desired alignment and paddings settings.
2. Set the alignment and paddings values in the LogoConfig object.
3. Use the LogoConfig object in conjunction with other SDK components that implement View.

Here is an example of how LogoConfig can be used to configure the logo alignment and additional paddings:

```kotlin
data class LogoConfig(
    val logoAlignment: LogoAlignment, // Alignment: BottomRight, BottomLeft, TopRight, TopLeft
    val logoAdditionalPaddings: Int // Additional paddings
)

// Create a LogoConfig object with the desired alignment and paddings
val logoConfig = LogoConfig(
    logoAlignment = LogoAlignment.BottomRight, // Set the logo alignment to BottomRight
    logoAdditionalPaddings = 10 // Set additional paddings to 10
)

// Use the LogoConfig object in conjunction with other SDK components
val mapView = MapView()
mapView.setLogoConfig(logoConfig)
```

By following these steps and using the LogoConfig object, you can easily configure the logo alignment and additional paddings in the Maps Mobile SDK."
How can legal entities and individual entrepreneurs enable monetization for their applications?,"[' is an electronic signature issued by the Federal Tax Service for your company. If you do not have an e-signature, contact a CEO, chief accountants, lawyers, HR specialists or procurement coordinators. Make sure that the employee with an EDS is entitled to sign financial documents. If in doubt, show them our Terms of Service.\n\nMonetization is available only to legal entities/individual entrepreneurs and application owners.\n\nHow to create and sign a request\n\nInstall the CryptoPro plugin to sign the request.\n\n1. Open the RuStore Console. 2. Click the ""Applications"" tab at the top of your screen. 3. Select ""Subscriptions"" in the left side menu, then go to the""Monetization"" section. 4. Click ""Fill out the form"".\n\nIf you accepted the terms before 12/22/2022, re-sign your application with an electronic signature.\n\n5. Fill in the data in the pop-up window. 6. Click ""Save and Continue"". 7. Read the payment terms for developers. 8. Click ""Create and Sign the request"".\n\n101\n\nSelect a signing certificate. The certificate must be issued on behalf of your company — we will check that the specified TIN matches the TIN of your company.\n\nYou can check your TIN in the certificate properties: in the operating system tools or in a certificate program (for example, CryptoPro).\n\nClick ""Sign a request"". It may take a few seconds to sign your request.\n\nOnce there, you can download the approved monetization request. Click ""Download a PDF-request"". Request example\n\n102\n\n103\n\nTest payments\n\nBackground\n\nYou can now test payments for subscriptions and in-app billing in your apps. The test purchase is carried out as a regular payment, though using test bank cards.\n\nFunctionality\n\nThe Test Payments function provides the following options:\n\nTest mode control via RuStore Console. ● Testing of payment scenarios in your app, which is carried out in an isolated test environment using special test cards and without affecting the release app version.\n\nView test payments history in RuStore Console.\n\nTechnical specifications\n\nYou can perform testing before publishing an app version to all users. ● In test mode, you can purchase the same products and subscriptions that were added to the release app version. At that, it is not necessary to publish them.\n\nYou can test the purchase of non-consumable items repeatedly (for example, access to the full app version or a skin in a game). To do that, you can return the payment via RuStore Console, and then make a purchase again in the application.\n\nIn test mode, special parameters are applied to subscriptions. They are independent of and do not affect the settings you select for the release app version. These technical features are designed to simplify and speed up testing.\n\nThe parameters in the table below are the same for all subscriptions in test mode.\n\nParameter\n\nValue\n\nMaximum number of subscription charges. After completing\n\n12\n\nthe specified number of debits, the subscription is\n\nautomatically closed\n\nPeriod between subscription charges\n\n10 mins\n\nOnce in 3 hours\n\nFrequency of resetting the free and starting period (purchase of subscriptions with a free and starting period). After the reset, you will again be able to purchase a subscription for free or at the initial price. This way you can test payment for a\n\n104\n\nsubscription several times under special conditions.\n\nRestrictions\n\nThe application owner is the only user who can test payments. He has exclusive access to the Test Payments section. Options to add other testers are now under development.\n\nTesting of a paid app purchase is not available in RuStore. ● The RuStore app does not display the history of test purchases and test subscriptions. This means that test subscriptions cannot be canceled or renewed.\n\nYou can pay for test purchases using test bank cards only. ● To test payments, at least the first app version must be moderated.\n\nBefore you start testing payments\n\nIntegrate the SDK that supports the payment testing function into the tested app —\n\nRuStore SDK billingclient 3.1.0 or higher.\n\nMake sure that the Android device on which you plan to test your app has RuStore\n\nversion 1.29 or higher installed.\n\nMake sure that your company is not blocked, that it has monetization enabled, and supports payment functionality in the app. You can set up subscriptions and paid products in RuStore Console, but not publish them to users.\n\nSee also\n\nHow to enable monetization - How to create a paid in-app product - How to create an app subscription\n\nEnable Test Mode\n\nYou can test payments after moderation is completed and before you publish a new app version']","Monetization is available only to legal entities/individual entrepreneurs and application owners. To enable monetization for their applications, they need to make sure that their company is not blocked, has monetization enabled, and supports payment functionality in the app. They can set up subscriptions and paid products in RuStore Console, but not publish them to users.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"Legal entities and individual entrepreneurs can enable monetization for their applications on RuStore by following these steps:

1. Open the RuStore Console.
2. Click the ""Applications"" tab at the top of the screen.
3. Select ""Subscriptions"" in the left side menu, then navigate to the ""Monetization"" section.
4. Click on ""Fill out the form"" to provide the necessary information.
5. If the terms were accepted before 12/22/2022, re-sign the application with an electronic signature.
6. Fill in the required data in the pop-up window.
7. Click on ""Save and Continue"" to proceed.
8. Review the payment terms for developers.
9. Finally, click on ""Create and Sign the request"" to enable monetization for their applications.

It's important to note that monetization is available only to legal entities/individual entrepreneurs and application owners on RuStore. Additionally, it is essential to have an electronic signature (EDS) issued by the Federal Tax Service for the company to sign the monetization request. If the company does not have an EDS, they can contact specific authorized personnel within the organization who are entitled to sign financial documents.","Legal entities and individual entrepreneurs can enable monetization for their applications on RuStore by following these steps:

1. Fill out an application for monetization by opening the RuStore Console, clicking on the ""Company"" tab, selecting ""Monetization"" in the left side menu, and then clicking on ""Apply for monetization.""

2. Provide the necessary information in the new window that appears, including general information and company details. Ensure that the Trade and legal name field is accurate according to your constituent documents. If there are any discrepancies, contact support and submit a new request with the correct data.

3. If the signatory differs from the company owner, fill in the required details such as position, name, last name, middle name (if included), and email. Additionally, upload documents establishing the signatory's authority.

4. Verify that the Tax number and Legal address match the information in your constituent documents. If the legal address differs from the actual one, provide the actual address where the company operates.

5. Fill in the ""Contacts for user feedback"" section with up-to-date contact details for users to reach out regarding app support, financial claims, or other inquiries. Ensure that the international phone number is entered in the Representative number field.

6. Sign the Additional agreement with the necessary authority and ensure that the certificate used for signing the request is issued on behalf of your company, with the Tax Identification Number (TIN) matching your company's TIN.

7. Once all the required information is provided and the request is signed, download the approved monetization request by clicking on ""Download a PDF-request.""

By following these steps, legal entities and individual entrepreneurs can successfully enable monetization for their applications on RuStore."
What information does the getAmount() method provide in the context of purchases?,"[' getPurchaseTime() — purchase time (in RFC 3339 format); ● getOrderId() — unique payment identifier generated by the application (uuid); ● getAmountLabel() — formatted purchase price, including the currency symbol in [language];\n\ngetAmount() — price in minor units of currency; ● getCurrency() — ISO 4217 currency code; ● getQuantity() — number of products; ● getPurchaseState() — purchase status:\n\n268\n\npossible values of the purchase condition:\n\n■ CREATED — created; ■ INVOICE_CREATED — created, waiting for payment; ■ CONFIRMED — confirmed; ■ PAID — paid for; ■ CANCELLED — purchase canceled; ■ CONSUMED — purchase consumption is confirmed; ■ CLOSED — subscription is canceled.\n\ngetDeveloperPayload() — line specified by the developer that contains additional\n\ninformation about the order;\n\ngetSubscriptionToken() — token for validating a purchase on the server.\n\nThe purchaseState model:\n\nA status-based subscription purchase model (SUBSCRIPTIONS):\n\n269\n\nA status-based non-consumables subscription (NON-CONSUMABLES):\n\nA status-based consumables subscription (CONSUMABLES):\n\n270\n\nHow to get purchase info\n\nUse the getPurchaseInfo method to get information about purchases:\n\nPurchasesUseCase purchasesUseCase = billingClient.getPurchases();\n\npurchasesUseCase.getPurchaseInfo(""purchaseId"").addOnCompleteListene\n\nr(new OnCompleteListener<PurchaseInfoResponse>() {\n\n@Override\n\npublic void onFailure(@NonNull Throwable throwable) {\n\n// Process error\n\n}\n\n@Override\n\npublic void onSuccess(PurchaseInfoResponse result) {\n\n// Process success\n\n}\n\n});\n\nProduct Structure:\n\ninterface Purchase {\n\n@Nullable\n\npublic String getPurchaseId();\n\npublic String getProductId();\n\n@Nullable\n\npublic ProductType getProductType();\n\n@Nullable\n\npublic String getInvoiceId();\n\n@Nullable\n\npublic String getDescription();\n\n@Nullable\n\npublic String getLanguage();\n\n@Nullable\n\npublic Date getPurchaseTime();\n\n271\n\n}\n\n@Nullable\n\npublic String getOrderId();\n\n@Nullable\n\npublic String getAmountLabel();\n\n@Nullable\n\npublic Integer getAmount();\n\n@Nullable\n\npublic String getCurrency();\n\n@Nullable\n\npublic Integer getQuantity();\n\n@Nullable\n\npublic PurchaseState getPurchaseState();\n\n@Nullable\n\npublic String getDeveloperPayload();\n\n@Nullable\n\npublic String getSubscriptionToken();\n\ngetPurchaseId() — purchase ID; ● getProductId() — product identifier; ● getProductType() — product type; ● getInvoiceId() — invoice ID; ● getDescription() — purchase description; ● getLanguage() — language specified with the BCP 47 encoding; ● getPurchaseTime() — purchase time (in RFC 3339 format); ● getOrderId() — unique payment identifier generated by the application (uuid); ● getAmountLabel() — formatted purchase price, including the currency symbol in [language];\n\ngetAmount() — price in minor units of currency; ● getCurrency() — ISO 4217 currency code; ● getQuantity() — number of products; ● getPurchaseState() — purchase status:\n\npossible values of the purchase condition:\n\n■ CREATED — created;\n\n272\n\n■ INVOICE_CREATED — created, waiting for payment; ■ CONFIRMED — confirmed; ■ PAID — paid for; ■ CANCELLED — purchase canceled; ■ CONSUMED — purchase consumption is confirmed; ■ CLOSED — subscription is canceled.\n\ngetDeveloperPayload() — line specified by the developer that contains additional\n\ninformation about the order;\n\ngetDeveloperPayload() — token for server purchase validation.\n\nThe purchaseState model:\n\nA status-based subscription purchase model (SUBSCRIPTIONS):\n\n273\n\nA status-based non-consumables subscription (NON-CONSUMABLES):\n\nA status-based consumables subscription (CONSUMABLES):\n\n274\n\nHow to handle purchases\n\nUse the purchaseProduct method to call a product purchase:\n\nPurchasesUseCase purchasesUseCase = billingClient.getPurchases();\n\npurchasesUseCase.purchaseProduct(""productId"").addOnCompleteListener\n\n(new OnCompleteListener<PaymentResult>() {\n\n@']",The getAmount() method provides the price of the purchase in minor units of currency.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The getAmount() method provides the price in minor units of currency in the context of purchases. This means that the amount returned by the getAmount() method represents the price of the purchase in the smallest units of the currency being used. For example, if the currency is USD, the amount returned by getAmount() would be in cents.","The `getAmount()` method in the context of purchases provides the price of the purchase in minor units of currency. This means that the `getAmount()` method returns the cost of the purchase in the smallest units of the currency being used. For example, if the purchase is priced at $10.99, the `getAmount()` method would return the value of 1099, representing 1099 cents or minor units of the currency.

If you have any more questions or need further clarification, feel free to ask!"
What are the instance methods available for the LngLat object in the given context?,"['36)""\n\n746\n\nwrap()\n\nReturns a new LngLat object whose longitude is wrapped in the range (from -180 to +180).\n\nExample:\n\nvar ll = new mmrgl.LngLat(286.0251, 40.7736); var wrapped = ll.wrap(); wrapped.lng; // = -73.9749\n\nLngLatLike\n\nLngLat can be an array of two numbers (longitude and latitude), or an object with lng and lat or lon and lat properties.\n\nsrc/geo/lng_lat.js\n\nExample:\n\nvar v1 = new mmrgl.LngLat(-122.420679, 37.772537);\n\nvar v2 = [-122.420679, 37.772537];\n\nvar v3 = {lon: -122.420679, lat: 37.772537};\n\nLngLatBounds\n\nThe LngLatBounds object represents the boundary defined by its southwest and northeast points in longitude and latitude.\n\nIf no arguments are provided, a null boundary is created.\n\nAny MMR GL method that takes a LngLatBounds object as an argument or option can also take an array of two LngLatLike constructs and perform an implicit conversion. This flexible type is documented as LngLatBoundsLike.\n\nsrc/geo/lng_lat_bounds.js\n\nOptions sw:number — longitude in degrees ne:number — latitude in degrees\n\nstatic methods\n\nName\n\nDescription\n\n747\n\nconvert(input) Converts an array to a LngLatBounds object.\n\nIf a LngLatBounds object is passed, the function returns it unchanged. Internally, the function calls LngLat#convert to convert arrays to LngLat values.\n\nOptions: input:LngLatBoundsLike An array of two coordinates to transform, or LngLatBounds to return.\n\nExample:\n\nvar arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]]; var llb = mmrgl.LngLatBounds.convert(arr); llb; lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n\n// = LngLatBounds {_sw: LngLat {lng: -73.9876,\n\ninstance methods\n\nName\n\nDescription\n\ncontains(lnglat)\n\nCheck if the point is inside the bounding box.\n\nOptions: lnglat:LngLatLike\n\nExample: var llb = new mmrgl.LngLatBounds( new mmrgl.LngLat(-73.9876, 40.7661), new mmrgl.LngLat(-73.9397, 40.8002) );\n\nvar ll = new mmrgl.LngLat(-73.9567, 40.7789);\n\nconsole.log(llb.contains(ll)); // = true\n\nextend(obj)\n\nExpand the bounds to include the given LngLatLike or LngLatBounds\n\nOptions: obj:(LngLatLike | LngLatBoundsLike) extension object\n\n748\n\ngetCenter()\n\ngetEast()\n\ngetNorth()\n\ngetNorthEast()\n\ngetNorthWest()\n\ngetSouth()\n\ngetSouthEast()\n\ngetSouthWest()\n\ngetWest()\n\nisEmpty()\n\nsetNorthEast(ne)\n\nsetSouthWest(sw )\n\ntoArray()\n\nReturns a geographic coordinate equidistant from the corners of the bounding box.\n\nExample: var llb = new mmrgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]); llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}\n\nReturns the east edge of the bounding box.\n\nReturns the north edge of the bounding box.\n\nReturns the northeast corner of the bounding box.\n\nReturns the northwest corner of the bounding box.\n\nReturns the south edge of the bounding box.\n\nReturns the southeast corner of the bounding box.\n\nReturns the southwest corner of the bounding box.\n\nReturns the southwest corner of the bounding box.\n\nCheck if the bounding box is empty/null.\n\nSets the northeast corner of the bounding']","The instance methods available for the LngLat object in the given context are: getCenter(), getEast(), getNorth(), getNorthEast(), getNorthWest(), getSouth(), getSouthEast(), getSouthWest(), getWest(), isEmpty(), setNorthEast(ne), setSouthWest(sw), toArray()",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The instance methods available for the LngLat object in the given context are:
- wrap()
- convert(input)

The wrap() method returns a new LngLat object whose longitude is wrapped in the range from -180 to +180. It takes no arguments and is used to wrap the longitude value.

The convert(input) method converts an array of two numbers or an object with properties lng and lat or lon and lat to an LngLat object. If an LngLat object is passed as input, the function returns it unchanged. The input parameter can be an array of two numbers, an object to convert, or an LngLat object to return. 

These are the instance methods available for the LngLat object as per the provided documentation.","The instance methods available for the LngLat object in the given context are:

1. **distanceTo(lngLat):** This method returns the approximate distance between a pair of coordinates in meters using the Haversine formula. It takes the coordinates to estimate the distance to the target as an input.

   Example:
   ```
   var newYork = new mmrgl.LngLat(-74.0060, 40.7128);
   var losAngeles = new mmrgl.LngLat(-118.2437, 34.0522);
   newYork.distanceTo(losAngeles); // = 3935751.690893987
   ```

2. **toArray():** This method returns the coordinates represented as an array of two numbers.

   Example:
   ```
   var ll = new mmrgl.LngLat(-73.9749, 40.7736);
   ll.toArray(); // = [-73.9749, 40.7736]
   ```

3. **toBounds(radius):** This method returns LngLatBounds from coordinates extended by the given radius. The returned LngLatBounds contains the entire radius.

   Options:
   - radius: Distance in meters from the coordinates to extend the bounds.

   Example:
   ```
   var ll = new mmrgl.LngLat(-73.9749, 40.7736);
   ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
   ```

4. **toString():** This method returns the coordinates represented as a string.

   Example:
   ```
   var ll = new mmrgl.LngLat(-73.9749, 40.7736);
   ll.toString(); // = ""LngLat(-73.9749, 40.7736)""
   ```

5. **wrap():** This method returns a new LngLat object whose longitude is wrapped in the range from -180 to +180.

   Example:
   ```
   var ll = new mmrgl.LngLat(286.0251, 40.7736);
   var wrapped = ll.wrap();
   wrapped.lng; // = -73.9749
   ```

These are the instance methods available for the LngLat object in the given context."
What information does the getAmount() method provide in the context of purchases?,"[' getPurchaseTime() — purchase time (in RFC 3339 format); ● getOrderId() — unique payment identifier generated by the application (uuid); ● getAmountLabel() — formatted purchase price, including the currency symbol in [language];\n\ngetAmount() — price in minor units of currency; ● getCurrency() — ISO 4217 currency code; ● getQuantity() — number of products; ● getPurchaseState() — purchase status:\n\n268\n\npossible values of the purchase condition:\n\n■ CREATED — created; ■ INVOICE_CREATED — created, waiting for payment; ■ CONFIRMED — confirmed; ■ PAID — paid for; ■ CANCELLED — purchase canceled; ■ CONSUMED — purchase consumption is confirmed; ■ CLOSED — subscription is canceled.\n\ngetDeveloperPayload() — line specified by the developer that contains additional\n\ninformation about the order;\n\ngetSubscriptionToken() — token for validating a purchase on the server.\n\nThe purchaseState model:\n\nA status-based subscription purchase model (SUBSCRIPTIONS):\n\n269\n\nA status-based non-consumables subscription (NON-CONSUMABLES):\n\nA status-based consumables subscription (CONSUMABLES):\n\n270\n\nHow to get purchase info\n\nUse the getPurchaseInfo method to get information about purchases:\n\nPurchasesUseCase purchasesUseCase = billingClient.getPurchases();\n\npurchasesUseCase.getPurchaseInfo(""purchaseId"").addOnCompleteListene\n\nr(new OnCompleteListener<PurchaseInfoResponse>() {\n\n@Override\n\npublic void onFailure(@NonNull Throwable throwable) {\n\n// Process error\n\n}\n\n@Override\n\npublic void onSuccess(PurchaseInfoResponse result) {\n\n// Process success\n\n}\n\n});\n\nProduct Structure:\n\ninterface Purchase {\n\n@Nullable\n\npublic String getPurchaseId();\n\npublic String getProductId();\n\n@Nullable\n\npublic ProductType getProductType();\n\n@Nullable\n\npublic String getInvoiceId();\n\n@Nullable\n\npublic String getDescription();\n\n@Nullable\n\npublic String getLanguage();\n\n@Nullable\n\npublic Date getPurchaseTime();\n\n271\n\n}\n\n@Nullable\n\npublic String getOrderId();\n\n@Nullable\n\npublic String getAmountLabel();\n\n@Nullable\n\npublic Integer getAmount();\n\n@Nullable\n\npublic String getCurrency();\n\n@Nullable\n\npublic Integer getQuantity();\n\n@Nullable\n\npublic PurchaseState getPurchaseState();\n\n@Nullable\n\npublic String getDeveloperPayload();\n\n@Nullable\n\npublic String getSubscriptionToken();\n\ngetPurchaseId() — purchase ID; ● getProductId() — product identifier; ● getProductType() — product type; ● getInvoiceId() — invoice ID; ● getDescription() — purchase description; ● getLanguage() — language specified with the BCP 47 encoding; ● getPurchaseTime() — purchase time (in RFC 3339 format); ● getOrderId() — unique payment identifier generated by the application (uuid); ● getAmountLabel() — formatted purchase price, including the currency symbol in [language];\n\ngetAmount() — price in minor units of currency; ● getCurrency() — ISO 4217 currency code; ● getQuantity() — number of products; ● getPurchaseState() — purchase status:\n\npossible values of the purchase condition:\n\n■ CREATED — created;\n\n272\n\n■ INVOICE_CREATED — created, waiting for payment; ■ CONFIRMED — confirmed; ■ PAID — paid for; ■ CANCELLED — purchase canceled; ■ CONSUMED — purchase consumption is confirmed; ■ CLOSED — subscription is canceled.\n\ngetDeveloperPayload() — line specified by the developer that contains additional\n\ninformation about the order;\n\ngetDeveloperPayload() — token for server purchase validation.\n\nThe purchaseState model:\n\nA status-based subscription purchase model (SUBSCRIPTIONS):\n\n273\n\nA status-based non-consumables subscription (NON-CONSUMABLES):\n\nA status-based consumables subscription (CONSUMABLES):\n\n274\n\nHow to handle purchases\n\nUse the purchaseProduct method to call a product purchase:\n\nPurchasesUseCase purchasesUseCase = billingClient.getPurchases();\n\npurchasesUseCase.purchaseProduct(""productId"").addOnCompleteListener\n\n(new OnCompleteListener<PaymentResult>() {\n\n@']",The getAmount() method provides the price in minor units of currency in the context of purchases.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The getAmount() method provides the price in minor units of currency in the context of purchases. This means that the method returns the price of the purchase in the smallest units of the currency being used, such as cents or pence.","The `getAmount()` method in the context of purchases provides the price in minor units of currency. This means that the `getAmount()` method returns the price of the purchase in the smallest units of the currency being used. For example, if the currency is in dollars, the `getAmount()` method would return the price in cents. It is important to note that this method gives the price in the smallest units to ensure accuracy and consistency in handling monetary values within the purchase information."
"What is the address details of Leningradsky Prospekt, 39 b79 in Moscow, Russia?","[' ID is not fixed and can be changed from time to time\n\ntype\n\nstring\n\nObject type\n\nname\n\nstring\n\nObject name\n\naddress_details fields description\n\nField name\n\nFormat\n\nDescription\n\n""name"": ""Leningradsky\n\nProspekt, 39 b79"",\n\n}\n\n]\n\n""address"": ""Russia, Moscow, Northern Administrative District, Moscow, Khoroshevsky, Leningradsky Prospekt, 39 b79"",\n\n""address_details"": {\n\n""building"": ""39 b79"", ""country"": ""Russia"", ""isocode"": ""RU"", ""locality"": ""Moscow"", ""region"": ""Moscow"", ""street"": ""Leningradsky\n\nProspekt"",\n\n""subregion"": ""Northern\n\nAdministrative District"",\n\n""suburb"": ""Khoroshevsky""\n\n}\n\n""ref"": ""1000000C4D63818""\n\n""type"": ""building""\n\n""name"": ""Leningradsky Prospekt, 39 b79""\n\nExample\n\n640\n\ncountry\n\nstring\n\nCountry\n\n""country"": ""Russia""\n\nisocode\n\n2char\n\n2-character code according to ISO 3166-1 alpha-2\n\n""isocode"": ""RU""\n\nregion\n\nstring\n\nRegion\n\n""region"": ""Moscow""\n\nsubregion\n\nstring\n\nSubregion\n\n""subregion"": ""Northern Administrative District""\n\nlocality\n\nstring\n\nLocality\n\n""locality"": ""Moscow""\n\nsublocality\n\nstring\n\nSublocality or community\n\n""sublocality"": ""Airport""\n\nstreet\n\nstring\n\nStreet\n\n""street"": ""Leningradsky""\n\nbuilding\n\nstring\n\nHouse, building\n\n""building"": ""39 b80""\n\nsuburb\n\nstring\n\nSuburb/neighborhood\n\n""suburb"": ""Khoroshevsky""\n\npostal_code\n\nstring\n\nPostal code\n\n""postal_code"": ""125167""\n\nExample\n\nRequest\n\nhttps://geo.rustore.ru/api/suggest?api_key=<YOUR_API_KEY>&limit=3&q=Mo\n\nscow%20Leningradsky%2039\n\nResponse\n\n641\n\n{\n\n""request"": ""/suggest?limit=2&q=Moscow Leningradsky\n\n39&api_key=demo_demo_main"",\n\n""results"": [\n\n{\n\n""address"": ""Russia, Moscow, Northern Administrative District,\n\nMoscow, Khoroshevsky, Leningradsky Prospekt, 39 79"",\n\n""name"": ""Leningradsky Prospekt, 39 79"",\n\n""type"": ""building""\n\n},\n\n{\n\n""address"": ""Russia, Moscow, Northern Administrative District,\n\nMoscow, Khoroshevsky, Leningradsky Prospekt, 39 b80"",\n\n""name"": ""Leningradsky Prospekt, 39 b80"",\n\n""type"": ""building""\n\n},\n\n{\n\n""address"": ""Russia, Moscow, Northern Administrative District,\n\nMoscow, Khoroshevsky, Leningradsky Prospekt, 39 3"",\n\n""name"": ""Alexander Gomelsky Universal Sports Hall CSKA"",\n\n""type"": ""building""\n\n}\n\n]\n\n}\n\n642\n\nMap display services\n\nMap display services are designed to help you embed an interactive and static map into your products.\n\nAn interactive map — service that allows you to embed a map on a website or app, enabling the user to change the scale, angle and position of the display, as well as to add various elements to the map using JS: pins, curves, highlighting, etc.\n\nA static map — service that allows you to get a map image with pins placed on it as a PNG or JPG image.\n\nServices\n\nCall point\n\nDescription\n\nInteractive map\n\n/staticmap\n\nStatic map\n\n643\n\nInteractive map\n\nQuick start 1. Map 2. Properties and options 3. Tags and controls 4. Geography and geometry 5. Handlers 6. Sources 7. Events 8. How to use the library in React applications Description of additional map objects\n\nThe following components are required to display an interactive map:\n\ndisplay data (tiles); ● display style; ● map']","The address details of Leningradsky Prospekt, 39 b79 in Moscow, Russia are as follows: building - 39 b79, country - Russia, isocode - RU, locality - Moscow, region - Moscow, street - Leningradsky Prospekt, subregion - Northern Administrative District, suburb - Khoroshevsky",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The address details of Leningradsky Prospekt, 39 b79 in Moscow, Russia are as follows:
- Building: 39 b79
- Country: Russia
- Locality: Moscow
- Region: Moscow
- Street: Leningradsky Prospekt
- Subregion: Northern Administrative District
- Suburb: Khoroshevsky

This information is provided in the document on page 640.","The address details of Leningradsky Prospekt, 39 b79 in Moscow, Russia are as follows:
- Building: 39 b80
- Country: Russia
- Locality: Moscow
- Postal Code: 125167
- Region: Moscow
- Street: Leningradsky Prospekt
- Subregion: Northern Administrative District
- Suburb: Khoroshevsky

Please note that the specific address you mentioned, Leningradsky Prospekt, 39 b79, is not listed in the provided information. The closest address details available are for Leningradsky Prospekt, 39 b80."
What is the purpose of obtaining the User Review ID in the API response?,"['\nmessage\n\nstring\n\nNo\n\nResponse decoded message\n\ntimestamp\n\ntimestam\n\nYes\n\nResponse time\n\n2022-07-08T13:24:41.832871\n\nptz\n\n1+03:00\n\n1028\n\nbody{}\n\nobject\n\nYes\n\nbody{}\n\nAttribute\n\nType\n\nRequired\n\nDescription\n\nExample\n\ncontent\n\nid\n\nnumber\n\nYes\n\nUser Review ID\n\n748479\n\nExample\n\ncurl --location\n\n\'https://public-api.rustore.ru/public/v1/application/ru.voonsh.push/feedback?commentId=2\n\n142370751\' \\\n\n--header \'Content-Type: application/json\' \\\n\n--header \'Public-Token:\n\neyJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiUlNBLU9BRVAtMjU2In0.ziOR4J-_3A36M55IMdJqx\n\nck4Lktk9GFe6vvdRFBkIICA6z4WLLUxdEyHNdMWYomBs9MkJecCaCStOQ5YtmHvFIR\n\nK8aoj4c386WwUBXmTDXN_BJg2puwuLivMJWuAhgveZpC7afZCwM6m5RgLi538BAjFV\n\n_gE8XvbSUKlhWhkEvIzgrK2zk211SRUVXaAdrWEz5NNSSrQhyEv1fiMgQNmV9Sehp8fx\n\nP7G_9HkAWVtfNvgEiTbFHMTO-qpWtdh5Ts440Du9MC7PL59IUmXts1Khx6xbuUWLQe\n\n3WHPQCBmKezpxtI-l9Ms4F-iopZy-bXzUaUMFsaQu8Jh4kFvztFenYg.UPvgd5jKQcFO-M\n\nRE.zHHu-P5GSwUTvEMae-bu337jxpq25TbftTC7oF8r0APCfUqdx55CbO-PuIeGdjN08K4\n\nIC8GsWhLmKr9mqEeV9L-Dh5QSqA6M7GsLH8LAqrR1UX0Z849pyhrOt_Pz4SJ3YeHdu-\n\nITfTL5Ysr0kECMXWIMcE24X8U.zHXeYuxDJf-Wtl9Vn0betw\' \\\n\n--data \'{\n\n""message"": ""Thank you""\n\n}\'\n\nExample response\n\n{\n\n""code"": ""OK"",\n\n""message"": null,\n\n""body"": {\n\n""id"": 2149775551\n\n},\n\n""timestamp"": ""2023-06-02T16:36:57.847391009+03:00""\n\n}\n\n1029\n\nGetting review response status\n\nUse this method to obtain the response-to-review moderation status or either information on a\n\nseparate response.\n\nRestrictions:\n\nBy default, each page displays 20 reviews. You can display up to 100 reviews per\n\npage by specifying a value in the size parameter;\n\nYou cannot use pagination and filtering parameters together based on 1 response to\n\na review (or pagination by specifying a pair of parameters page and size or id).\n\nInteraction Options\n\nGET\n\nhttps://public-api.rustore.ru/public/v1/application/{packageName}/feedback/?id={id}&page={\n\nnumber}&size={size}\n\nAttribute Type Required Location\n\nDescription\n\nExample\n\ncontent\n\nPublic-To\n\nstring Yes\n\nheader\n\nken\n\nRuStore Public API Access\n\nToken\n\npackage\n\nstring Yes\n\npath\n\nApp package name. Maximum\n\ncom.myapp.e\n\nName\n\nlength: 50 characters\n\nxample\n\nfeedback\n\nnum\n\nNo\n\npath\n\nid of a specific response-to-\n\n743103\n\n']",The purpose of obtaining the User Review ID in the API response is to uniquely identify and reference a specific user review for further actions or analysis.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"When obtaining the User Review ID in the API response, the purpose is to retrieve information about a specific response to a review. This ID is used to uniquely identify the review response that the developer wants to retrieve details for. By specifying the User Review ID in the API request, developers can access specific information related to that particular review response, such as the moderation status or other details associated with the review.","Obtaining the User Review ID in the API response serves the purpose of uniquely identifying a specific review provided by a user. This ID allows developers to reference and retrieve individual reviews for further analysis or action. By using the User Review ID, developers can track, respond to, or delete specific reviews based on the feedback received from users. Additionally, the User Review ID can be used to monitor changes to reviews, such as edits made by users, as indicated by the ""edited"" attribute in the review data."
What is the direction to Sheremetyevo Terminal D?,"['\n\n835\n\n""type"":24,\n\n""instruction"":""Keep left to exit onto\n\n46Н—13925/Mezhdunarodnoe highway."",\n\n""verbal_transition_alert_instruction"":""Keep\n\nleft to exit onto 46Н—13925."",\n\n""verbal_pre_transition_instruction"":""Keep left\n\nto exit onto 46Н—13925, Mezhdunarodnoe highway."",\n\n""verbal_post_transition_instruction"":""Continue\n\nfor another 2.5 km."",\n\n""street_names"":[\n\n""46Н—13925"",\n\n""Mezhdunarodnoe highway""\n\n],\n\n""time"":89.576,\n\n""length"":2.654,\n\n""cost"":75.352,\n\n""begin_shape_index"":372,\n\n""end_shape_index"":384,\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":24,\n\n""instruction"":""Keep left to stay on\n\n46Н—13925/Mezhdunarodnoe highway."",\n\n""verbal_transition_alert_instruction"":""Keep\n\nleft to stay on 46Н—13925."",\n\n""verbal_pre_transition_instruction"":""Keep left\n\nto stay on 46Н—13925, Mezhdunarodnoe highway."",\n\n""verbal_post_transition_instruction"":""Continue\n\ndriving for another 1.5 km."",\n\n""street_names"":[\n\n""46Н—13925"",\n\n""Mezhdunarodnoe highway""\n\n],\n\n""time"":50.683,\n\n""length"":1.254,\n\n""cost"":46.611,\n\n""begin_shape_index"":384,\n\n""end_shape_index"":403,\n\n""travel_mode"":""drive"",\n\n836\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":24,\n\n""instruction"":""Keep left towards Sheremetyevo,\n\nTerminal D."",\n\n""verbal_transition_alert_instruction"":""Keep\n\nleft towards Sheremetyevo."",\n\n""verbal_pre_transition_instruction"":""Keep left\n\ntowards Sheremetyevo, Terminal D."",\n\n""verbal_post_transition_instruction"":""Continue\n\nfor another 500 meters."",\n\n""time"":33.139,\n\n""length"":0.46,\n\n""cost"":38.839,\n\n""begin_shape_index"":403,\n\n""end_shape_index"":413,\n\n""sign"":{\n\n},\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":23,\n\n""instruction"":""Keep right at the fork."",\n\n""verbal_transition_alert_instruction"":""Keep\n\nright at the fork."",\n\n""verbal_pre_transition_instruction"":""Keep\n\nright at the fork."",\n\n""verbal_post_transition_instruction"":""Continue\n\nfor another 600 meters."",\n\n""time"":43.991,\n\n""length"":0.61,\n\n""cost"":63.974,\n\n""begin_shape_index"":413,\n\n""end_shape_index"":439,\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n837\n\n""type"":4,\n\n""instruction"":""You have reached your\n\ndestination."",\n\n""verbal_transition_alert_instruction"":""You\n\nhave reached your destination."",\n\n""verbal_pre_transition_instruction"":""You have\n\nreached your destination."",\n\n""time"":0.0,\n\n""length"":0.0,\n\n""cost"":0.0,\n\n""begin_shape_index"":439,\n\n""end_shape_index"":439,\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n}\n\n],\n\n""summary"":{\n\n""ll_boxes"":[{\n\n""min_lat"":55.79378,\n\n""min_lon"":37.39366,\n\n""max_lat"":55.962686,\n\n""max_lon"":37.546925,\n\n}],\n\n']",The direction to Sheremetyevo Terminal D is to keep left.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To get to Sheremetyevo Terminal D, you need to ""Keep left towards Sheremetyevo, Terminal D."" This instruction is provided in the document with a verbal transition alert instruction to keep left towards Sheremetyevo and a verbal pre-transition instruction to keep left towards Sheremetyevo, Terminal D. Additionally, there is a verbal post-transition instruction to continue for another 500 meters after keeping left towards Sheremetyevo, Terminal D.","To reach Sheremetyevo Terminal D, you need to follow these directions:

1. Keep left towards Sheremetyevo, Terminal D. Continue for another 500 meters.
2. Keep right at the fork. Continue for another 600 meters.

These instructions will guide you towards Sheremetyevo Terminal D according to the provided documentation."
How can push notifications be enabled in a Flutter project using RuStore?,"[' and will send notification to it. All further notifications with no channel specified will be sent to this channel.\n\nOpening Activity when notification is pressed on\n\nBy default, RuStoreSDK opens activity with ‘android.intent.action.MAIN’ action whenever a notification is pressed on. If ‘clickAction’ field is present, RuStoreSDK will open activity which falls under ‘Intent filter’ with specified ‘action’.\n\nFor activity to open in RuStoreSDK when a notification is pressed on (this also applies to default activity), add <category android:name=""android.intent.category.DEFAULT"" /> line in the corresponding activity’s <intent-filter> element in app’s manifest. Activity will not open in RuStoreSDK without this line.\n\n443\n\nError handling\n\nPossible errors:\n\nRuStoreNotInstalledException() — user’s device doesn’t have RuStore installed. ● RuStoreOutdatedException() — RuStore installed on a user\'s device doesn’t support push notifications.\n\nRuStoreUserUnauthorizedException() — the user is not logged in to the RuStore. ● RuStoreFeatureUnavailableException() — RuStore app is not allowed to run in the background.\n\nRuStoreException(message: String) — RuStore basic error from which all the other\n\nerrors are inherited.\n\nIf the allowNativeErrorHandling == true parameter was passed during SDK initialization, when an error occurs, it is passed to the resolveForPush method of the native SDK and calls the corresponding onFailure handler,:\n\nfun RuStoreException.resolveForPush(context: Context)\n\nYou can change this behavior after initialization by setting the AllowNativeErrorHandling\n\nproperty:\n\nRuStorePushClient.Instance.AllowNativeErrorHandling = false;\n\n444\n\nFlutter\n\nGeneral Checking ability to receive push notification How to work with push tokens and push notifications Notification structure\n\n241 243 244 246\n\n445\n\nGeneral\n\nImplementation example\n\nSee the example app to learn how to integrate package for push notifications handling correctly.\n\nPush notifications enabling conditions\n\nFor push notifications to be enabled, the following conditions need to be met:\n\n1. The RuStore app is installed on the user\'s device. 2. The RuStore app supports push notifications. 3. The RuStore app is allowed to run in the background. 4. The user has logged in to the RuStore.\n\nEnabling in project\n\nTo enable package in project, execute the following command: flutter pub add flutter_rustore_push\n\nThis command will add a line to pubspec.yaml file. dependencies:\n\nflutter_rustore_push: ^1.0.0\n\nInitialization\n\nTo initialize push notifications service, add a value to ‘values’ of your android project:\n\n<resources>\n\n<string name=""flutter_rustore_push_project""\n\ntranslatable=""false"">xxx</string>\n\n</resources>\n\nxxx — project’s identifier. The field’s name in the RuStore Console, in ‘Push notifications -> Projects’ section, is ‘Project ID’.\n\nTo start push notification service, Application class inherited from FlutterRustoreApplication needs to be added.\n\nAn example of how to do this in Kotlin:\n\npackage ru.rustore.flutter_rustore_push_example\n\nimport ru.rustore.flutter_rustore_push.FlutterRustoreApplication\n\nopen class Application: FlutterRustoreApplication() {\n\n}\n\n446\n\nSpecify the following class in AndroidManifest.xml:\n\n<application\n\nandroid:label=""flutter_rustore_push_example""\n\nandroid:name="".Application""\n\nandroid:icon=""@mipmap/ic_launcher"">\n\n// ...\n\n</application>\n\nConfiguring ProGuard\n\nTo configure ProGuard, add the following rule:\n\nkeep public class com.vk.push.** extends android.os.Parcelable\n\nAdd the following code in android/app/build.gradle:\n\nbuildTypes {\n\nrelease {\n\n// ...\n\nproguardFiles\n\ngetDefaultProguardFile(\'proguard-android.txt\'),\n\n\'proguard-rules.pro\'\n\n}\n\n// ...\n\n}\n\n447\n\nChecking ability to receive push notification\n\nFor push notifications to be enabled, all the conditions must be met:\n\n1. The RuStore app is installed on the user\'s device. 2. The']","To enable push notifications in a Flutter project using RuStore, the RuStore app must be installed on the user's device, the app must support push notifications, the app must be allowed to run in the background, and the user must be logged in to the RuStore. Additionally, the flutter_rustore_push package needs to be added to the project dependencies and the push notification service needs to be initialized by adding a value to the 'values' of the android project. The Application class inherited from FlutterRustoreApplication also needs to be added to start the push notification service.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To enable push notifications in a Flutter project using RuStore, you need to follow these steps:

1. Ensure that the RuStore app is installed on the user's device.
2. Confirm that the RuStore app supports push notifications.
3. Verify that the RuStore app is allowed to run in the background.
4. Make sure the user has logged in to the RuStore.

To enable the package in your project, you should execute the following command:
```
flutter pub add flutter_rustore_push
```
This command will add a line to the `pubspec.yaml` file under dependencies:
```
dependencies:
  flutter_rustore_push: ^1.0.0
```

To initialize the push notifications service, you need to add a value to the 'values' of your Android project. This value should be the project's identifier obtained from the RuStore Console under the 'Push notifications -> Projects' section, known as 'Project ID'.

Additionally, to start the push notification service, you must have the Application class inherited from `FlutterRustoreApplication`. An example of how to do this in Kotlin is as follows:
```kotlin
package ru.rustore.flutter_rustore_push_example

import ru.rustore.flutter_rustore_push.FlutterRustoreApplication

open class Application : FlutterRustoreApplication() {
}
```

By following these steps, you can enable push notifications in your Flutter project using RuStore.","To enable push notifications in a Flutter project using RuStore, you need to follow these steps:

1. **Installation**:
   - Execute the following command to add the Flutter RuStore Push package to your project:
     ```
     flutter pub add flutter_rustore_push
     ```
   - This command will add a line to your `pubspec.yaml` file under dependencies.

2. **Initialization**:
   - Add a value to the `values` of your Android project resources:
     ```
     <resources>
       <string name=""flutter_rustore_push_project"" translatable=""false"">xxx</string>
     </resources>
     ```
     Replace `xxx` with your project's identifier from the RuStore Console in the 'Push notifications -> Projects' section.

3. **Application Class**:
   - Create a custom `Application` class in Kotlin that inherits from `FlutterRustoreApplication`.
     ```
     package ru.rustore.flutter_rustore_push_example

     import ru.rustore.flutter_rustore_push.FlutterRustoreApplication

     open class Application: FlutterRustoreApplication() {
     }
     ```
   - Specify this custom class in your `AndroidManifest.xml` under the `<application>` tag:
     ```
     <application
         android:label=""flutter_rustore_push_example""
         android:name="".Application""
         android:icon=""@mipmap/ic_launcher"">
         <!-- ... -->
     </application>
     ```

4. **ProGuard Configuration**:
   - Add the following ProGuard rule to your ProGuard configuration file:
     ```
     -keep public class com.vk.push.** extends android.os.Parcelable
     ```
   - Include the ProGuard rule in your `android/app/build.gradle` file under `buildTypes`.

5. **Checking Ability to Receive Push Notifications**:
   - Ensure that the RuStore app is installed, supports push notifications, is allowed to run in the background, and the user is logged in to RuStore.
   - You can use `RustorePushClient.available()` method to check if these conditions are met.

By following these steps, you can enable push notifications in your Flutter project using RuStore."
What steps should be followed to enable monetization for foreign companies on RuStore?,"["" visible to users. Please enter the international phone number in the Representative number field.\n\nYou can also specify the preferred method of communication and add a link to instant messengers, a feedback form, or another tool used to receive feedback from users (optional). We also recommend checking the availability of this tool for users from the Russian Federation.\n\n116\n\n4. Contract information\n\nCompany's chief accountant full name. - Accounting statements: income statement, balance sheet. - Documents confirming tax residency. A tax residency certificate is provided to avoid double taxation. Going forward, we will ask you to update this document annually.\n\n117\n\n5. Bank details.\n\nProvide the company bank account details in either a Russian or foreign\n\nbank, where the settlements will be processed.\n\nNote. If there is no currency listed which would be convenient for you to make payments, please contact support@rustore.ru and we will consider your offer.\n\n118\n\n\n\nIf you want to make payments through a specific correspondent bank, please specify the required details in this section. We will send your income to these details for further transfer to you. Otherwise, we will transfer your income to the details specified above through our standard correspondent bank.\n\n119\n\nThe Additional agreement outlines the process for currency conversion during payment.\n\nNote. RuStore charges a fee on paid apps and in-app items (subscriptions, in-app purchases). The fee for non-residents is 15%. In cases where RuStore is required to be a tax agent of a non-resident, apart from the fee, the amount of taxes payable in accordance with the legislation of the Russian Federation will be withheld.\n\n6. Click Submit a request. 7. Check the request text and click Go to submit. Your monetization request will be reviewed and approved by a moderator.\n\nNote. You can withdraw the request at any stage and make the necessary changes whenever so required, and then re-submit for review.\n\nAttention. In case of discrepancy, we will notify you by email and ask you to attach the correct documents, while we reserve the right to reject the request and / or either block the monetization option in exceptional circumstances.\n\nOnce you have submitted the moderation request, we will send the Additional agreement to your email. Read the agreement and sign it to enable monetization.\n\n120\n\nNote. Please note that the Supplementary Agreement must be signed by the person whose information you have indicated in the Company Representative section above.\n\nOnce monetization is enabled for you, you will be able to set up subscriptions, in-app products and publish paid apps. You will receive a monthly report on accepted payments. We will transfer payments to you in accordance with the Additional agreement.\n\nPayments are scheduled once a month at most, provided that the minimum amount has been reached since the previous payment.\n\n121\n\nPayments management\n\nIn RuStore Console you can monitor payments per monetization-enabled app.\n\nViewing payments information\n\n1. Open RuStore Console.\n\n2. Select Applications in the top menu.\n\n3. From the menu on the left select Monetization > Payment management.\n\nThe payment information table is displayed only if the app was purchased at least once. The table contains:\n\ndate and time of a purchase; ● invoice number and order number; ● payment card number and phone number from which the payment was made; ● purchase amount; ● invoice status.\n\nOnly subscription payments have order number. Order number is the same for all payments of a subscription.\n\nClick on a payment to see the detailed information.\n\n122\n\nPayment search\n\nTo search and view payment information, follow these steps:\n\n1. Open RuStore Console. 2. Select Applications in the top menu. 3. From the menu on the left select Monetization > Payment management. 4. Enter the invoice number in the search field. The payment amount and status information will be displayed. Select one of the identifiers as a search criteria — invoice number or order number. After that, enter the invoice or order number in the search field accordingly. In the search results, you'll see all in-app payments that match the selected search criteria.\n\n123\n\nA payment can have one of the following statuses:\n\nProcessing: the money on the buyer's payment card is put on hold. The purchase is waiting to be confirmed.\n\nCanceled: the money on the buyer's payment card is released from hold. The purchase is canceled.\n\nPaid: transaction confirmed, the funds are debited from the buyer's account.\n\nRefunded: the funds are returned to the buyer's account. The refund time may be up to 5 business days.\n\nPayment return\n\nTo return a payment to the buyer, follow these steps:\n\n1. Open""]",The answer to given question is not present in context,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To enable monetization for foreign companies on RuStore, the following steps should be followed:

1. Open the RuStore Console.
2. Click the Company tab at the top of your screen.
3. Select Monetization in the left side menu.
4. Then click Apply for monetization.

Additionally, to sell in-app products and subscriptions on the RuStore store, you need to fill out a monetization request and sign it with an EDS (electronic signature) issued by the Federal Tax Service for your company. If you do not have an e-signature, you can contact a CEO, chief accountants, lawyers, HR specialists, or procurement coordinators who have the authority to sign financial documents. Monetization is available only to legal entities/individual entrepreneurs and application owners.","To enable monetization for foreign companies on RuStore, the following steps should be followed:

1. Open the RuStore Console.
2. Click on the Company tab at the top of your screen.
3. Select Monetization in the left side menu.
4. Click on Apply for monetization.
5. Fill in the data in the new window that appears.

When filling out the monetization request, ensure to provide accurate information as per the guidelines provided in the documentation. It is important to follow the instructions carefully to successfully enable monetization for your company on RuStore.

If you encounter any issues or need assistance during the process, you can contact RuStore support for further guidance."
What are the possible payment results that can be returned when making a purchase using RustoreBillingClient?,"["" — purchase confirmed; ● CLOSED — subscription canceled.\n\nGetting Specific Purchase Info\n\nTo get a specific purchase, you must use the\n\nRustoreBillingClient.getPurchaseInfo(purchaseId) method:\n\n379\n\ntry {\n\nconst purchase = await\n\nRustoreBillingClient.getPurchaseInfo('purchaseId');\n\nconsole.log(purchase?.purchaseId);\n\n} catch (err) {\n\nconsole.log(`purchase err: ${err}`);\n\n}\n\npurchaseId — purchase ID.\n\nThis method returns Purchase, which is described above.\n\nHow to handle purchases\n\nUse the RustoreBillingClient.purchaseProduct({...})` method to call a product purchase:\n\ntry {\n\nconst response = await RustoreBillingClient.purchaseProduct({\n\nproductId: 'productId',\n\norderId: 'orderId',\n\nquantity: 0,\n\ndeveloperPayload: 'developerPayload'\n\n});\n\nconsole.log(`purchase success: ${response}`);\n\n} catch (err) {\n\nconsole.log(`purchase err: ${err}`);\n\n}\n\nproduct_id — product ID; ● order_id — order ID, created on the AnyApp side (optional. If not specified, it is generated automatically); ● invoice_id — account ID; ● product_id — product ID; ● quantity — number of products (optional); ● payload — additional information from the AnyApp developer (optional). ● error_code — error code in case of failed request.\n\n380\n\nThe purchase result can be represented as one of the following interfaces:\n\nSuccessPayment, CanceledPayment or FailurePayment:\n\nenum PaymentResult {\n\nSUCCESS = 'SUCCESS', CANCELLED = 'CANCELLED', FAILURE = 'FAILURE',\n\n}\n\ninterface SuccessPaymentResult {\n\norderId?: string; purchaseId: string; productId: string; invoiceId: string; subscriptionToken?: string;\n\n}\n\ninterface SuccessPayment {\n\ntype: PaymentResult.SUCCESS; result: SuccessPaymentResult;\n\n}\n\ninterface CancelledPaymentResult {\n\npurchaseId: string;\n\n}\n\ninterface CancelledPayment {\n\ntype: PaymentResult.CANCELLED; result: CancelledPaymentResult;\n\n}\n\ninterface FailurePaymentResult {\n\npurchaseId?: string; invoiceId?: string; orderId?: string; quantity?: number; productId?: string; errorCode?: number;\n\n}\n\ninterface FailurePayment {\n\ntype: PaymentResult.FAILURE; result: FailurePaymentResult;\n\n}\n\n381\n\nSuccessPayment — product successfully purchased. ● FailurePayment — purchase failed. ● CancelledPayment — purchase canceled.\n\n382\n\nPurchase confirmation\n\nThe RuStore application consists of the following types of products:\n\nCONSUMABLE — consumables (multiple-time purchases, such as crystals in the\n\napp);\n\nNON_CONSUMABLE — non-consumables (one-time purchases, such as disabling\n\nads in an app);\n\nSUBSCRIPTION — subscription (can be purchased for a period of time, such as a\n\nstreaming service subscription).\n\nOnly CONSUMABLE type products require confirmation if they are in the PurchaseState.PAID state.\n\nYou can use the RustoreBillingClient.confirmPurchase({...}) method to confirm the purchase:\n\ntry {\n\nconst isConfirmed = await RustoreBillingClient.confirmPurchase({\n\npurchaseId: 'purchaseId',\n\ndeveloperPayload: 'developerPayload'\n\n})\n\nconsole.log(`confirm success: ${isConfirmed}`);\n\n} catch (err) {\n\nconsole.log(`confirm err: ${err}`);\n\n}\n\n-\n\npurchaseId — purchase ID. developerPayload — developer-specified string containing additional information.\n\nProvided that all conditions are met, the RustoreBillingClient.confirmPurchase() method returns true.\n\n383\n\nPurchase cancellation\n\nYou can use the RustoreBillingClient.deletePurchase(purchaseId) method to cancel the purchase:\n\ntry {\n\nconst isDeleted = await\n\nRustoreBillingClient.deletePurchase(purchaseId)\n\nconsole.log(`delete success: ${isDeleted}`);\n\n} catch (err""]","The possible payment results that can be returned when making a purchase using RustoreBillingClient are SuccessPayment, CanceledPayment, and FailurePayment.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"When making a purchase using RustoreBillingClient, the possible payment results that can be returned are represented by the following interfaces:

1. SuccessPayment:
   - This interface represents a successful payment result.
   - It includes the following fields:
     - orderId (optional): string
     - purchaseId: string
     - productId: string
     - invoiceId: string
     - subscriptionToken (optional): string

2. CancelledPayment:
   - This interface represents a canceled payment result.
   - It includes the following field:
     - purchaseId: string

3. FailurePayment:
   - This interface represents a failed payment result.
   - It includes the following fields:
     - purchaseId (optional): string
     - invoiceId (optional): string
     - orderId (optional): string
     - quantity (optional): number
     - productId (optional): string
     - errorCode (optional): number

These payment results are defined within the PaymentResult enum, which includes the following possible values:
- SUCCESS: 'SUCCESS'
- CANCELLED: 'CANCELLED'
- FAILURE: 'FAILURE'

Therefore, when using RustoreBillingClient to make a purchase, the payment result can be one of the above interfaces based on whether the payment was successful, canceled, or failed.","When making a purchase using RustoreBillingClient, the possible payment results that can be returned are:

1. SuccessPayment: Represents a successful payment. It includes fields such as orderId, purchaseId, productId, invoiceId, and subscriptionToken (optional).
   
2. CancelledPayment: Represents a canceled payment. It includes the purchaseId field.

3. FailurePayment: Represents a failed payment. It includes fields such as purchaseId, invoiceId (optional), orderId (optional), quantity (optional), productId (optional), and errorCode (optional).

Additionally, there is a PaymentResult Enum that defines the following values:
- SUCCESS: Payment was successful.
- CANCELLED: Payment was canceled.
- FAILURE: Payment failed.

These payment results help in determining the outcome of the purchase process in the RustoreBillingClient."
How should you navigate in order to drive north-west?,"['instruction"":""Drive north-west, then turn\n\nright onto Leningradsky Prospekt."",\n\n""verbal_pre_transition_instruction"":""Drive\n\nnorth-west, then turn right onto Leningradsky Prospekt."",\n\n""verbal_post_transition_instruction"":""Continue\n\ndriving for another 50 meters."",\n\n""time"":8.72,\n\n""length"":0.048,\n\n""cost"":364.824,\n\n""begin_shape_index"":0,\n\n""end_shape_index"":3,\n\n""verbal_multi_cue"":true,\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":10,\n\n""instruction"":""Turn right onto Leningradsky\n\nProspekt."",\n\n""verbal_transition_alert_instruction"":""Turn\n\nright onto Leningradsky Prospekt."",\n\n""verbal_succinct_transition_instruction"":""Turn\n\nright."",\n\n""verbal_pre_transition_instruction"":""Turn\n\nright onto Leningradsky Prospekt."",\n\n""verbal_post_transition_instruction"":""Continue\n\ndriving for another 600 meters."",\n\n""street_names"":[\n\n""Leningradsky Prospekt""\n\n],\n\n""time"":37.931,\n\n""length"":0.593,\n\n""cost"":72.21,\n\n""begin_shape_index"":3,\n\n828\n\n""end_shape_index"":12,\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":13,\n\n""instruction"":""Turn left to keep dring along\n\nLeningradsky Prospekt."",\n\n""verbal_transition_alert_instruction"":""Turn\n\nleft to keep dring along Leningradsky Prospekt."",\n\n""verbal_succinct_transition_instruction"":""Turn\n\nleft."",\n\n""verbal_pre_transition_instruction"":""Turn left\n\nto keep dring along Leningradsky Prospekt."",\n\n""verbal_post_transition_instruction"":""Continue\n\ndriving for another 10 km."",\n\n""street_names"":[\n\n""Leningradsky Prospekt""\n\n],\n\n""time"":535.509,\n\n""length"":10.369,\n\n""cost"":682.537,\n\n""begin_shape_index"":12,\n\n""end_shape_index"":164,\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":23,\n\n""instruction"":""Keep right at the fork."",\n\n""verbal_transition_alert_instruction"":""Keep\n\nright at the fork."",\n\n""verbal_pre_transition_instruction"":""Keep\n\nright at the fork."",\n\n""verbal_post_transition_instruction"":""Continue\n\ndriving for another 400 meters."",\n\n""time"":34.122,\n\n""length"":0.378,\n\n""cost"":55.773,\n\n""begin_shape_index"":164,\n\n""end_shape_index"":174,\n\n829\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":15,\n\n""instruction"":""Turn left."",\n\n""verbal_transition_alert_instruction"":""Turn\n\nleft."",\n\n""verbal_succinct_transition_instruction"":""Turn\n\nleft."",\n\n""verbal_pre_transition_instruction"":""Turn\n\nleft."",\n\n""verbal_post_transition_instruction"":""Continue\n\ndriving for another 400 meters."",\n\n""time"":45.832,\n\n""length"":0.435,\n\n""cost"":75.448,\n\n""begin_shape_index"":174,\n\n""end_shape_index"":195,\n\n""travel_mode"":""drive"",\n\n""travel_type"":""car""\n\n},\n\n{\n\n""type"":9,\n\n""instruction"":""Turn right onto Leningradskoye\n\nhighway."",\n\n""verbal_transition_alert_instruction"":""Turn\n\nright onto Leningradskoye highway."",\n\n""verbal_succinct_transition_instruction"":""Turn\n\nright, then after 300 meters,']","Drive north-west, then turn right onto Leningradsky Prospekt.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,I dont know,"To navigate in order to drive north-west, you should follow these instructions from the document:

1. Turn left to keep driving along Leningradsky Prospekt.
2. Keep right at the fork.
3. Turn left.
4. Turn right onto Leningradskoye highway.
5. Turn right.
6. Turn right.
7. Turn left.
8. Turn right onto Leningradskoye highway/Leningrad highway.
9. Enter the roundabout and take the 3rd exit onto Belomorskaya Street.
10. Exit the roundabout onto Belomorskaya Street.

These instructions will guide you in a north-west direction according to the provided documentation."
How can an activity be opened when a notification is pressed on in RuStoreSDK?,"[' activity is opened when a notification is pressed\n\non.\n\nCreating channel for sending notification\n\nThe following order of priority is used for the channel to which notification will be sent:\n\n1.\n\n2.\n\n3.\n\nIf there is ‘channelId’ field in push notification, then RuStoreSDK will send notification to this channel. Note that your app is responsible for creating this channel in advance. If there is no ‘channelId’ field in push notification, but your app has specified parameter with channel in AndroidManifest.xml, then channel from AndroidManifest.xml will be used. Your app is responsible for creating the channel. If there is no ‘channelId’ field in push notification, and no default channel has been set in your app’s AndroidManifest.xml, then RuStoreSDK will create channel itself and will send notification to it. All further notifications with no channel specified will be sent to this channel.\n\nOpening Activity when notification is pressed on\n\nBy default, RuStoreSDK opens activity with ‘android.intent.action.MAIN’ action whenever a notification is pressed on. If ‘clickAction’ field is present, RuStoreSDK will open activity which falls under ‘Intent filter’ with specified ‘action’.\n\nFor activity to open in RuStoreSDK when a notification is pressed on (this also applies to default activity), add <category android:name=""android.intent.category.DEFAULT"" /> line in the corresponding activity’s <intent-filter> element in app’s manifest. Activity will not open in RuStoreSDK without this line.\n\n416\n\nEvent logging\n\nIf you wish to log events of push notification library, add ‘logger’ parameter to RuStorePushClient.init call (this parameter is not required for initialization).\n\nTo do this, ‘Logger’ interface needs to be implemented:\n\ninterface Logger {\n\nfun verbose(message: String, throwable: Throwable? = null)\n\nfun debug(message: String, throwable: Throwable? = null)\n\nfun info(message: String, throwable: Throwable? = null)\n\nfun warn(message: String, throwable: Throwable? = null)\n\nfun error(message: String, throwable: Throwable? = null)\n\nfun createLogger(tag: String): Logger\n\n}\n\nIf Logger has not been sent, then default implementation with AndroidLog will be used.\n\npublic class DefaultLogger(\n\nprivate val tag: String? = null,\n\n) : Logger {\n\noverride fun verbose(message: String, throwable: Throwable?) {\n\nLog.v(tag, message, throwable)\n\n}\n\noverride fun debug(message: String, throwable: Throwable?) {\n\nLog.d(tag, message, throwable)\n\n}\n\noverride fun info(message: String, throwable: Throwable?) {\n\nLog.i(tag, message, throwable)\n\n}\n\noverride fun warn(message: String, throwable: Throwable?) {\n\nLog.w(tag, message, throwable)\n\n}\n\noverride fun error(message: String, throwable: Throwable?) {\n\nLog.e(tag, message, throwable)\n\n}\n\noverride fun createLogger(tag: String): Logger {\n\nval newTag = if (this.tag != null) {\n\n417\n\n}\n\n}\n\n""${this.tag}:$tag""\n\n} else { tag\n\n} return DefaultLogger(newTag)\n\n418\n\nError handling\n\nPossible errors:\n\nRuStoreNotInstalledException() — user’s device doesn’t have RuStore installed. ● RuStoreOutdatedException() — RuStore installed on a user\'s device doesn’t support push notifications.\n\nRuStoreUserUnauthorizedException() — the user is not logged in to the RuStore. ● RuStoreFeatureUnavailableException() — RuStore app is not allowed to run in the background.\n\nRuStoreException(message: String) — RuStore basic error from which all the other\n\nerrors are inherited.\n\nIf you wish to use UI interface for error handling, then use resolveForPush() method:\n\nfun RuStoreException.resolveForPush(context: Context)\n\nE2E Testing of Push Notifications SDK\n\nTo have testing enabled, the following conditions need to be met: 1. The RuStore app is installed on the']","An activity can be opened when a notification is pressed on in RuStoreSDK by adding the <category android:name=""android.intent.category.DEFAULT"" /> line in the corresponding activity’s <intent-filter> element in the app’s manifest. This line is necessary for the activity to open in RuStoreSDK when a notification is pressed on.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To open an activity when a notification is pressed on in RuStoreSDK, you can follow these steps:

1. By default, RuStoreSDK opens the activity with the 'android.intent.action.MAIN' action when a notification is pressed on.
2. If the 'clickAction' field is present in the notification, RuStoreSDK will open the activity that falls under the 'Intent filter' with the specified 'action'.
3. To ensure that the activity opens in RuStoreSDK when a notification is pressed on, including the default activity, you need to add the following line in the corresponding activity's <intent-filter> element in the app's manifest:
```xml
<category android:name=""android.intent.category.DEFAULT"" />
```
4. It is important to note that the activity will not open in RuStoreSDK without this line in the manifest.

These steps will help you configure RuStoreSDK to open a specific activity when a notification is pressed on.","To open an activity when a notification is pressed on in RuStoreSDK, you need to follow these steps:

1. By default, RuStoreSDK opens the activity with the 'android.intent.action.MAIN' action when a notification is pressed on.
2. If the 'clickAction' field is present in the notification, RuStoreSDK will open the activity that falls under the 'Intent filter' with the specified 'action'.

Additionally, to ensure that the activity opens in RuStoreSDK when a notification is pressed on, you need to add the following line in the corresponding activity's `<intent-filter>` element in your app's manifest:
```xml
<category android:name=""android.intent.category.DEFAULT"" />
```

This line is essential for the activity to open in RuStoreSDK when a notification is pressed on. Without this line, the activity will not open in RuStoreSDK.

Therefore, by setting the 'clickAction' field in the notification and adding the specified line in the activity's `<intent-filter>` element, you can control which activity opens when a notification is pressed on in RuStoreSDK."
How do you add a Maven repository link to connect Maps Mobile SDK in Android apps?,"['return coordinates;\n\n}; C++ 11\n\n#include <vector>\n\nconstexpr double kPolylinePrecision = 1E6;\n\nconstexpr double kInvPolylinePrecision = 1.0 / kPolylinePrecision;\n\nstruct PointLL {\n\nfloat lat;\n\nfloat lon;\n\n};\n\nstd::vector<PointLL> decode(const std::string& encoded) {\n\nsize_t i = 0;\n\n// what byte are we looking at\n\n// Handy lambda to turn a few bytes of an encoded string into an\n\ninteger\n\nauto deserialize = [&encoded, &i](const int previous) {\n\n// Grab each 5 bits and mask it in where it belongs using the\n\nshift\n\nint byte, shift = 0, result = 0;\n\ndo {\n\nbyte = static_cast<int>(encoded[i++]) - 63;\n\nresult |= (byte & 0x1f) << shift;\n\nshift += 5;\n\n868\n\n} while (byte >= 0x20);\n\n// Undo the left shift from above or the bit flipping and add to\n\nprevious\n\n// since its an offset\n\nreturn previous + (result & 1 ? ~(result >> 1) : (result >> 1));\n\n};\n\n// Iterate over all characters in the encoded string\n\nstd::vector<PointLL> shape;\n\nint last_lon = 0, last_lat = 0;\n\nwhile (i < encoded.length()) {\n\n// Decode the coordinates, lat first for some reason\n\nint lat = deserialize(last_lat);\n\nint lon = deserialize(last_lon);\n\n// Shift the decimal point 5 places to the left\n\nshape.emplace_back(static_cast<float>(static_cast<double>(lat) *\n\nkInvPolylinePrecision),\n\nstatic_cast<float>(static_cast<double>(lon) *\n\nkInvPolylinePrecision));\n\n// Remember the last one we encountered\n\nlast_lon = lon;\n\nlast_lat = lat;\n\n}\n\nreturn shape;\n\n}\n\nPython\n\n#!/usr/bin/env python\n\nimport sys\n\n#six degrees of precision in valhalla\n\ninv = 1.0 / 1e6;\n\ndef decode(encoded):\n\n""""""Decodes route polyline which is returned by rose.""""""\n\n869\n\ndecoded = []\n\ni = 0\n\nprevious_coords = {\'lat\': 0, \'lon\': 0}\n\nwhile i < len(encoded):\n\ncoords = dict()\n\nfor coord_name in (\'lat\', \'lon\'):\n\ncoord = 0\n\nshift = 0\n\nbyte = 0x20\n\n# Keep decoding bytes until you have this coord.\n\nwhile byte >= 0x20:\n\nbyte = ord(encoded[i]) - 63\n\ni += 1\n\ncoord |= (byte & 0x1f) << shift\n\nshift += 5\n\n# Get the final value adding the previous offset and\n\n# remember it for the next.\n\ncoords[coord_name] = previous_coords[coord_name] + (\n\n~(coord >> 1)\n\nif coord & 1\n\nelse (coord >> 1)\n\n)\n\n# Scale by the precision and chop off long coords.\n\n# Also flip the positions so its the far more standard\n\n# (lon, lat) instead of (lat, lon).\n\ndecoded.append([\n\nfloat(f""{coords[\'lon\'] * inv:.6f}""),\n\nfloat(f""{coords[\'lat\'] * inv:.6f}""),\n\n])\n\nprevious_coords = coords\n\nreturn decoded\n\nprint decode(sys.argv[1])\n\n870\n\nMaps Mobile SDK\n\nMaps SDK allows you to add a map to your iOS and Android apps.\n\n871\n\nAndroid\n\nHow to connect Maps Mobile SDK\n\nTo connect Maps SDK, you need to add a maven repository link to the main gradle file of the project:\n\nallprojects {\n\nrepositories {\n\nmaven {\n\nurl =\n\nuri(""https://maven.pkg.github.com/GEORS/MAPS-SDK-ANDROID"")\n\ncredentials {\n\nusername = ""GITHUB_USER""\n\npassword = ""GITHUB_TOKEN']","To connect Maps SDK in Android apps, you need to add a Maven repository link to the main gradle file of the project under 'allprojects' -> 'repositories' -> 'maven' with the URL 'https://maven.pkg.github.com/GEORS/MAPS-SDK-ANDROID' and credentials including username and password.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To add a Maven repository link to connect Maps Mobile SDK in Android apps, you need to include the following configuration in the main gradle file of the project:

```groovy
allprojects {
    repositories {
        maven {
            url = uri(""https://maven.pkg.github.com/GEORS/MAPS-SDK-ANDROID"")
            credentials {
                username = ""GITHUB_USER""
                password = ""GITHUB_TOKEN""
            }
        }
    }
}
```

This configuration specifies the Maven repository link where the Maps SDK can be found. Additionally, you should specify the dependency in the gradle file using the following format:

```groovy
implementation('ru.rustore.geo:mapkit:x.x.x')
```

In this format, `x.x.x` represents the SDK version. It is recommended to use the latest SDK version, and the release versions of the SDK are numbered as `1.0.x`. You can find the latest SDK version at the following link: [Maps SDK Android Repository](https://github.com/geors?tab=packages&repo_name=maps-sdk-android).

This information is based on the provided documentation for connecting Maps Mobile SDK in Android apps.","To add a Maven repository link to connect Maps Mobile SDK in Android apps, you need to include the repository link in the main gradle file of your project. Here is the step-by-step guide:

1. Open the main gradle file of your project.

2. Add the following code snippet inside the `allprojects` block:

```groovy
allprojects {
    repositories {
        maven {
            url = uri(""https://maven.pkg.gipub.com/GEORS/MAPS-SDK-ANDROID"")
            credentials {
                username = ""GITHUB_USER""
                password = ""GITHUB_TOKEN""
            }
        }
    }
}
```

3. Replace `GITHUB_USER` and `GITHUB_TOKEN` with your GitHub username and token respectively.

By following these steps and adding the Maven repository link to your main gradle file, you will be able to connect the Maps Mobile SDK in your Android app."
What are the App Review Guidelines for publishing an app on RuStore?,"['rustore.ru\n\nSpecialists will initiate an appeal and check that the application belongs to the applicant. Upon successful identification, the support specialist will deactivate the old certificate. After that, the developer just needs to upload the new APK file with an updated signing certificate common to RuStore and other stores.\n\n78\n\nPaid apps\n\nYou can set your app as free or paid when adding a new app to the RuStore Console,\n\nEnable monetization to upload paid apps.\n\n1. Open the RuStore Console. 2. Click the ""Applications"" tab. 3. Click ""Add an app"". 4. Enter the name of your app in the pop-up window. 5. Select the app type: ""Free"" or ""Paid"". 6. Click ""Add"".\n\nYou cannot change a free app to a paid app on the RuStore.\n\nOnce you selected the ""Free"" app type, it cannot be changed to ""Paid"". If you want to charge for such an app, you need to re-upload it with a new name.\n\nYou can also update your app prices when editing or when uploading a new app version.\n\nHow to change the app price\n\n1. Open the RuStore Console. 2. Click the ""Applications"" tab.\n\n79\n\n3. Select an application. 4. Click ""Edit"". 5. Enter the new app price.\n\nRuStore service fee for paid apps is 15%. In case RuStore acts as the developer’s tax\n\nagent, apart from service fee, taxes will be withheld in accordance with the legislation of the Russian Federation.\n\n6. Click ""Submit for moderation"".\n\nBefore submitting your app for moderation, be sure to check the application for compliance with the App Review Guidelines.\n\nA new app version will be created and sent for moderation. After the moderation, the status of your application will be changed and the ""Publish"" button will appear.\n\nClick ""Publish"" to make your app available to users. The new app price will be displayed on the RuStore.\n\n80\n\n81\n\nTo set up in-app product pricing, see how to create paid in-app items.\n\nTo set up subscription pricing, see how to create an app subscription\n\n82\n\nApp Review Guidelines\n\nBefore your app is published on the RuStore, it needs to pass mandatory review. Throughout this process you’ll go through the entire user journey to make sure that your app works properly, corresponds to the declared category and age rating without neither posing any security risks nor threatening the laws and rights of other users. Non-compliance with the specified requirements may result in the application being declined for publication or, if violations are identified after review, the app may be removed from the store.\n\nFollow a few steps below to double-check your app before publishing it on the RuStore:\n\n1. Your app performance meets the following requirements: ● It runs and works steadily without failures and errors; ● All declared app features work correctly; ● We do not allow publishing apps that cause crashes, force close, freeze or work with errors;\n\nYour app must be self-sustaining and have original content. We discourage applications that are primarily designed to redirect to a website (WebView). An application may duplicate a website functionality or use a WebView to perform certain options, but it must be represented as a complete, standalone product. We reserve the right to block your app if we suspect that it is published solely to drive traffic to a website;\n\nYour app should not contain abundant advertising that will interfere with its usage (ads\n\nafter each user action), or either with no options to remove ads from the screen; ● Each user should be able to successfully pass through authorization whenever so\n\nrequired without redirecting to third-party resources;\n\nFor limited-audience apps only: specify test account data in a comment and send it for\n\nreview;\n\nDo not forget to provide test authorization data to RuStore moderators in the ""Comments\n\nfor moderators"" field to test the app functionality. Make sure that the demo mode shows all the app features.\n\nMake sure that your app is adapted to most modern mobile devices - no errors and\n\nincorrect layout of applications are allowed.\n\n2. Your app content is designed as follows: The application, its page and user content must be completely free of the following:\n\nany ethically inappropriate statements or ideas: overt discrimination, rabble-rousing,\n\ninsults (except of playful jokes), etc.;\n\noffers for sale or distribution of illegal goods (prescription drugs, narcotic substances,\n\nweapons, tobacco and nicotine products to-be-delivered, etc.) and services (prostitution, forgery, hacking services, cheating, etc.) .);\n\nprohibited pornographic content (ob']","Before your app is published on the RuStore, it needs to pass mandatory review. Throughout this process you’ll go through the entire user journey to make sure that your app works properly, corresponds to the declared category and age rating without neither posing any security risks nor threatening the laws and rights of other users. Non-compliance with the specified requirements may result in the application being declined for publication or, if violations are identified after review, the app may be removed from the store. Follow a few steps below to double-check your app before publishing it on the RuStore: 1. Your app performance meets the following requirements: ● It runs and works steadily without failures and errors; ● All declared app features work correctly; ● We do not allow publishing apps that cause crashes, force close, freeze or work with errors; Your app must be self-sustaining and have original content. We discourage applications that are primarily designed to redirect to a website (WebView). An application may duplicate a website functionality or use a WebView to perform certain options, but it must be represented as a complete, standalone product. We reserve the right to block your app if we suspect that it is published solely to drive traffic to a website; Your app should not contain abundant advertising that will interfere with its usage (ads after each user action), or either with no options to remove ads from the screen; ● Each user should be able to successfully pass through authorization whenever so required without redirecting to third-party resources; For limited-audience apps only: specify test account data in a comment and send it for review; Do not forget to provide test authorization data to RuStore moderators in the ""Comments for moderators"" field to test the app functionality. Make sure that the demo mode shows all the app features. Make sure that your app is adapted to most modern mobile devices - no errors and incorrect layout of applications are allowed. 2. Your app content is designed as follows: The application, its page and user content must be completely free of the following: any ethically inappropriate statements or ideas: overt discrimination, rabble-rousing, insults (except of playful jokes), etc.; offers for sale or distribution of illegal goods (prescription drugs, narcotic substances, weapons, tobacco and nicotine products to-be-delivered, etc.) and services (prostitution, forgery, hacking services, cheating, etc.) .); prohibited pornographic content (ob",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The App Review Guidelines for publishing an app on RuStore include the following requirements:

1. App Performance:
- The app must run steadily without failures or errors.
- All declared app features must work correctly.
- Apps that cause crashes, force close, freeze, or work with errors are not allowed.
- The app must be self-sustaining with original content.
- Excessive advertising that interferes with app usage is discouraged.
- Users should be able to pass through authorization without redirecting to third-party resources.
- Test account data should be provided for limited-audience apps.
- Test authorization data should be provided to RuStore moderators for testing.
- The app must be adapted to modern mobile devices with no errors or incorrect layout.

2. App Content:
- The application, its page, and user content must be free of ethically inappropriate statements or ideas.
- Offers for sale or distribution of illegal goods and services are not allowed.
- Prohibited pornographic content is not allowed.

Failure to comply with these guidelines may result in the application being declined for publication or removed from the store if violations are identified after review.

These guidelines ensure that apps on RuStore meet certain standards of performance, content, and ethical considerations.","Before your app is published on the RuStore, it needs to pass a mandatory review. The review process ensures that your app works properly, corresponds to the declared category and age rating, and does not pose any security risks or violate the laws and rights of other users. Non-compliance with the requirements may result in the application being declined for publication or removed from the store if violations are identified after review.

To ensure your app meets the guidelines, you should consider the following:

1. **App Performance Requirements:**
   - Your app should run steadily without failures or errors.
   - All declared app features must work correctly.
   - Apps that cause crashes, force close, freeze, or have errors are not allowed.
   - Your app should be self-sustaining with original content. Applications primarily designed to redirect to a website (WebView) are discouraged. While an app may duplicate website functionality or use a WebView for certain options, it must be presented as a complete, standalone product.

These guidelines are crucial to follow to ensure that your app meets the necessary standards for publication on the RuStore."
How can the launch review flow be implemented in the application?,"['func _on_launch_review_review_flow_success():\n\npass\n\nfunc _on_launch_review_review_flow_flow_failure(error: RuStoreError):\n\npass\n\nUnset\n\nCalling the launch_review_flow method\n\n_review_client.launch_review_flow()\n\nWait for a notification that the user has completed the form in on_launch_review_flow_success or on_launch_review_flow_failure to continue the application. The callback on_launch_review_flow_flow_failure returns a RuStoreError object with error information.\n\nError handling\n\nThe errors that occur can be retrieved in *_failure events.\n\nError structure\n\n542\n\nUnset\n\nclass_name RuStoreError extends Object\n\nvar description: String\n\nfunc _init(json: String = """"):\n\nif json == """":\n\ndescription = """"\n\nelse:\n\nvar obj = JSON.parse_string(json)\n\ndescription = obj[""detailMessage""]\n\ndescription – error description.\n\n543\n\nPossible errors\n\nPossible errors you can get in onFailure:\n\nRuStoreNotInstalledException() — user’s device doesn’t have RuStore installed. ● RuStoreOutdatedException() — RuStore installed on a user\'s device doesn’t support the start of the rating and feedback process.\n\nRuStoreUserUnauthorizedException() — the user is not logged in to RuStore. ● RuStoreUserBannedException() — the user is blocked in RuStore. ● RuStoreApplicationBannedException() — the app is blocked in RuStore. ● RuStoreRequestLimitReached() — too little time elapsed since the last display of the process.\n\nRuStoreReviewExists() — this user has already rated your app. ● RuStoreInvalidReviewInfo() — problems with ReviewInfo. ● RuStoreException(message: String) — RuStore basic error from which all the other errors are inherited.\n\n544\n\nReact Native\n\nGeneral\n\nRuStore In-app Review SDK prompts the user to rate your app and leave feedback on the RuStore without exiting the app.\n\nRating and feedback user scenarios may be run at any time throughout the user’s path in your app. The user can rate your app from 1 to 5 and leave feedback. Feedback is optional.\n\nImplementation example\n\nSee the example app to learn how to integrate rating and feedback SDK correctly.\n\nUse case example\n\nConditions for correct operation of SDK\n\nFor rating and feedback SDK to operate correctly, the following conditions need to be met:\n\n11. Android 6.0 or later. 12. The RuStore app is installed on the user\'s device. 13. The current RuStoreApp version is installed on the user\'s device. 14. The user has logged in to the RuStore. 15. The app should be already installed on RuStore.\n\nWhen to ask to rate and leave feedback\n\nUse the tips below to decide when to ask the user to rate and leave feedback:\n\nStart the process once the user has been using your app for long enough. ● Avoid starting it too often as this will impair your app’s user experience and limit the use or SDK ratings.\n\n545\n\nAvoid using calls to action like “Rate App” button as the user could have already reached\n\nthe process starting limit.\n\nYour app should not ask the user any questions before the start or while the process is running, including their opinion (“Do you like the app?”) or predictive questions (“Would you give this app 5 stars?”).\n\nDesign tips\n\nUse the tips below to decide how to integrate the process:\n\nDisplay the process as is, without any intervention or modification of existing design,\n\nincluding size, opacity, shape and other properties.\n\nAdd nothing on top or on sides of the process. ● The process should open on top of all layers. Don’t close the process after starting. The process will close by itself after an express action by the user.\n\n546\n\nGetting started\n\nRun the following command to connect the package to the project.\n\nUnset\n\n// HTTPS.\n\nnpm install\n\ngit+https://git@gitflic.ru/project/rustore/react-native-rustore-review-sdk.git\n\n// SSH\n\nnpm install\n\ngit+ssh://git@gitflic.ru/project/rustore/react-native-rustore-review-sdk.git\n\nFeedback management Preparing to work with evaluations To display the evaluation window and review form']",The launch review flow can be implemented in the application by calling the method _review_client.launch_review_flow() and waiting for a notification that the user has completed the form in on_launch_review_flow_success or on_launch_review_flow_failure to continue the application. The callback on_launch_review_flow_flow_failure returns a RuStoreError object with error information.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To implement the launch review flow in your application, you need to follow these steps:

1. Call `requestReviewFlow()` in advance to prepare the necessary information to display. This step is crucial to ensure that the review flow is ready to be launched.
   
2. Save the `ReviewInfo` object locally when the `onSuccess` response is received after calling `requestReviewFlow()`. This `ReviewInfo` object will be used later to call `launchReviewFlow(reviewInfo)`.

3. If the `onFailure` response is received after calling `requestReviewFlow()`, handle the error appropriately. It is not recommended to display the error to the user since the user did not initiate this process.

4. When you are ready to launch the review flow, call `launchReviewFlow(reviewInfo)` and pass the saved `ReviewInfo` object as a parameter. This should be done within about five minutes of receiving the `onSuccess` response to ensure the `ReviewInfo` object is still valid.

By following these steps, you can successfully implement the launch review flow in your application.","To implement the launch review flow in your application using the RuStore In-app Review SDK, you need to follow these steps:

1. **Initialize RuStoreReviewManager**: To work with rates and reviews, initialize the RuStoreReviewManager. You can do this by calling `URuStoreReviewManager::Instance()->Init();`. This ties the object to the scene root. If you don't need to work with the object further, execute `Dispose()` to free memory.

2. **Request Review Flow**: Call `RequestReviewFlow()` in advance to prepare the necessary information to display the review flow. This method will return a unique `requestId` for each app launch. You can handle the success and failure callbacks to process the response or errors.

3. **Launch Review Flow**: Call the `LaunchReviewFlow()` method to actually launch the user's rating and review flow. Each request will return a `requestId` that is unique per app launch. You should wait for a notification after the user stops the flow in `onSuccess` or `onFailure`.

4. **Handle Errors**: Errors that occur during the process will be passed to the `onFailure` handler of the SDK methods. You can handle different types of errors such as `RuStoreNotInstalledException`, `RuStoreOutdatedException`, `RuStoreUserUnauthorizedException`, `RuStoreRequestLimitReached`, `RuStoreReviewExists`, `RuStoreInvalidReviewInfo`, or `RuStoreException`.

Remember, it's important to follow the guidelines provided in the documentation regarding when to prompt users for ratings and feedback, as well as how to design the flow without negatively impacting the user experience."
What event is triggered when the map has finished loading?,"[' map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when an error occurs. map.on(\'error\', function() {\n\nconsole.log(\'A error event occurred.\');\n\n});\n\n703\n\nidle\n\nload\n\nTriggered after the last frame drawn before the map enters the ""idle"" state: ● ● ●\n\nno camera transitions occur all currently requested tiles have been loaded all fade/transition animations have been completed\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // just before the map enters an ""idle"" state. map.on(\'idle\', function() {\n\nconsole.log(\'A idle event occurred.\');\n\n});\n\nTriggered immediately after all the necessary resources were loaded and the map was visually rendered for the first time.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the map has finished loading. map.on(\'load\', function() {\n\nconsole.log(\'A load event occurred.\');\n\n});\n\n704\n\nmousedown\n\nmouseenter\n\nTriggered when you click inside the map.\n\nThis event is compatible with the optional layerId parameter. If layerId is included as the second argument to Map#on, the event listener will only trigger when the cursor is clicked inside the visible part of the specified layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener map.on(\'mousedown\', function() {\n\nconsole.log(\'A mousedown event has occurred.\');\n\n});\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener for a specific layer map.on(\'mousedown\', \'poi-label\', function() {\n\nconsole.log(\'A mousedown event has occurred on a\n\nvisible portion of the poi-label layer.\'); });\n\nTriggered when the cursor enters the visible part of the specified layer beyond that layer or beyond the map canvas.\n\nThis event can only be listened for when Map#on includes three arguments, where the second argument specifies the desired layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener map.on(\'mouseenter\', \'water\', function() {\n\nconsole.log(\'A mouseenter event occurred on a visible\n\nportion of the water layer.\'); });\n\n705\n\nmouseleave\n\nmousemove\n\nTriggered when the cursor leaves the visible part of the specified layer or leaves the map canvas.\n\nThis event can only be listened for when Map#on includes three arguments, where the second argument specifies the desired layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the pointing device leaves // a visible portion of the specified layer. map.on(\'mouseleave\', \'water\', function() {\n\nconsole.log(\'A mouseleave event occurred.\');\n\n});\n\nTriggered when the cursor moves while the cursor is inside the map. When moving the cursor around the map, the event will trigger every time the cursor changes its position on the map.\n\nThis event is compatible with the optional layerId parameter. If layerId is included as the second argument to Map#on, the event listener will only trigger when the cursor is inside the visible part of the specified layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener map.on(\'mousemove\', function() {\n\nconsole.log(\'A mousemove event has occurred.\');\n\n});\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener for a specific layer map.on(\'mousemove\', \'poi-label\', function() {\n\nconsole.log(\'A mousemove event has occurred on a\n\nvisible portion of the poi-label layer.\'); });\n\n706\n\nmouseout\n\nmouseover\n\nTriggered when the mouse cursor leaves the map canvas.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the pointing device leave\'s // the map\'s canvas. map.on(\'mouseout\', function() {\n\nconsole.log(\'A mouseout event occurred.\');\n\n});\n\nTriggered when the mouse cursor moves inside the map.']",A load event occurred.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The event that is triggered when the map has finished loading is the 'load' event. This event is triggered immediately after all the necessary resources have been loaded and the map has been visually rendered for the first time. You can set an event listener for this using the code snippet provided in the documentation:

```javascript
map.on('load', function() {
  console.log('A load event occurred.');
});
```

This code will log a message to the console when the 'load' event is triggered after the map has finished loading.","The event triggered when the map has finished loading is called ""load"". This event is not explicitly mentioned in the provided documents, but in most mapping libraries, including Mapbox GL, the ""load"" event is commonly used to detect when the map has finished loading all its resources and is ready for interaction."
What is the process for handling push notifications and errors in the RuStoreUniversalPushClient?,"['_PROVIDER: String = ""rustore""\n\nTo get a specific token, use the code:\n\nresult[UNIVERSAL_FCM_PROVIDER].orEmpty()\n\nDeleting tokens\n\nTo delete tokens, you need to call the deleteTokens(token) method and pass a dictionary with a list of tokens.\n\nRuStoreUniversalPushClient.deleteTokens(\n\nmapOf(\n\nUNIVERSAL_RUSTORE_PROVIDER to ""xxx"", UNIVERSAL_FCM_PROVIDER to ""yyy"", UNIVERSAL_HMS_PROVIDER to ""zzz""\n\n507\n\n)\n\n)\n\nwhere xxx, yyy, zzz — tokens from different push notification providers.\n\n508\n\nTopics\n\nSubscribing to a topic\n\nTo subscribe to a topic, call the subscribeToTopic(""topic"") method.\n\nRuStoreUniversalPushClient.subscribeToTopic(""some_topic"")\n\nUnsubscribing from a topic\n\nTo unsubscribe from a topic, call the unsubscribeToTopic(""topic"") method.\n\nRuStoreUniversalPushClient.unsubscribeFromTopic(""some_topic"")\n\n509\n\nHandling events\n\nHandling onDeletedMessages Events\n\nTo manage the onDeletedMessages event, you should integrate an\n\nOnDeletedMessagesListener callback in the App class after initializing\n\nRuStoreUniversalPushClient. When the onDeletedMessages event is triggered, the callback will\n\nbe invoked, providing you with the providerType parameter. This parameter enables you to\n\ndetermine which push provider triggered the event.\n\nRuStoreUniversalPushClient.setOnDeletedMessagesListener { providerType ->\n\n// process event\n\n}\n\nHandling onNewToken Events\n\nTo manage the onNewToken event, it is necessary to include an OnNewTokenListener callback\n\nwithin the App class after initializing RuStoreUniversalPushClient. When the onNewToken event\n\nis triggered, a callback function will be invoked, and it will provide the following parameters:\n\nproviderType — determines which push provider triggered the event.\n\ntoken — new push token.\n\nRuStoreUniversalPushClient.setOnNewTokenListener { providerType, token ->\n\n// process event\n\n}\n\nHandling notifications\n\nTo receive notifications, it\'s essential to incorporate an OnMessageReceiveListener callback\n\nwithin the App class once you have initialized RuStoreUniversalPushClient. If notifications are\n\ndelivered via the universal API, they will undergo deduplication on the client side, and the\n\nnotification reception callback will be triggered just once.\n\nIn cases where the notification object contains data, RuStoreSDK will automatically handle the\n\nnotification display. However, if you prefer RuStoreSDK not to handle the notification display,\n\nyou can utilize the data object while keeping the notification object empty. Nevertheless, the\n\nOnMessageReceiveListener callback will still be invoked. You can retrieve the push notification\n\npayload (Map<String, String>) from the remoteMessage.data field.\n\n510\n\nRuStoreUniversalPushClient.setOnMessageReceiveListener { remoteMessage ->\n\n// process message\n\n}\n\nHandling push provider errors\n\nTo manage errors, it\'s essential to include an OnPushClientErrorListener callback in the App\n\nclass following the initialization of RuStoreUniversalPushClient. This callback will be invoked\n\nwith specific parameters when errors occur:\n\nproviderType — determines which push provider triggered the event.. ● errors — list of errors.\n\nRuStoreUniversalPushClient.setOnPushClientErrorListener { providerType, error ->\n\n// process error\n\n}\n\nIf HMS/FCM are already in use\n\nIf you use FCM/HMS services in your applications, add additional code to the services.\n\nFCM\n\nAdd the following code to the service for FCM:\n\nimport ru.rustore.sdk.universalpush.firebase.messaging.toNotificationPaylo ad\n\nclass MyFirebaseMessagingService: FirebaseMessagingService() {\n\noverride fun onMessageReceived(message: RemoteMessage) {\n\nsuper.onMessageReceived(message)\n\nRuStoreUniversalPushManager.processMessage(message.toNotificationPa yload())\n\n511\n\n}\n\noverride fun onNewToken(token: String) {\n\nsuper.onNewToken(token)\n\nRuStoreUniversalPushManager.processToken(token)\n\n}\n\n}\n\nHMS\n\nAdd the following code to the service for HMS:\n\nimport ru.rustore.sdk']","To handle push notifications and errors in the RuStoreUniversalPushClient, you can use various callbacks provided by the client. For handling deleted messages, you can integrate an OnDeletedMessagesListener callback to determine which push provider triggered the event. Similarly, for new token events, you can include an OnNewTokenListener callback to process the new token and determine the push provider that triggered the event. To receive notifications, incorporate an OnMessageReceiveListener callback to process the message payload. Lastly, to manage errors, include an OnPushClientErrorListener callback to handle errors and determine the push provider that triggered the event.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To handle push notifications and errors in the RuStoreUniversalPushClient, you need to follow these steps:

1. **Handling Push Notifications**:
   - Use the `RuStoreUniversalPushClient.setOnMessageReceiveListener` method to set a listener that will be invoked when a push message is received.
   - Inside the listener, you can process the received message.

2. **Handling Push Provider Errors**:
   - To manage errors, include an `OnPushClientErrorListener` callback in the App class after initializing the RuStoreUniversalPushClient.
   - This callback will be invoked with specific parameters when errors occur:
     - `providerType`: Determines which push provider triggered the event.
     - `errors`: List of errors.
   - Use the `RuStoreUniversalPushClient.setOnPushClientErrorListener` method to set a listener for handling errors.

3. **Additional Handling for FCM/HMS Services**:
   - If you are already using FCM/HMS services in your application, you need to add additional code to the services.
   - For FCM, you can import the necessary code and process the message received in the `onMessageReceived` method of your `MyFirebaseMessagingService` class.

Overall, by setting the appropriate listeners and callbacks, you can effectively handle push notifications and errors in the RuStoreUniversalPushClient.","To handle push notifications and errors in the RuStoreUniversalPushClient, you need to follow these steps:

1. **Handling Push Notifications**:
   - To enable push notifications, ensure that the RuStore app is installed on the user's device, supports push notifications, is allowed to run in the background, and the user is logged in to RuStore.
   - The notification structure includes fields like title, body, channelId, imageUrl, color, icon, and clickAction.
   - You can create a channel for sending notifications by specifying the channelId field in the push notification. If not specified, the channel from AndroidManifest.xml will be used, or RuStoreSDK will create a channel itself.
   - To open an activity when a notification is pressed, you can use the clickAction field. By default, RuStoreSDK opens the activity with 'android.intent.action.MAIN' action.
   - Ensure that the necessary metadata and services are declared in the AndroidManifest.xml file for customizing notification icons, colors, and channels.

2. **Handling Errors**:
   - The RuStoreUniversalPushClient provides error handling through specific exceptions like RuStoreNotInstalledException, RuStoreOutdatedException, RuStoreUserUnauthorizedException, RuStoreFeatureUnavailableException, and RuStoreException.
   - If the allowNativeErrorHandling parameter is set to true during SDK initialization, errors are passed to the resolveForPush method of the native SDK for handling.
   - You can change the error handling behavior by setting the AllowNativeErrorHandling property to false after initialization.

By following these steps and guidelines outlined in the RuStoreUniversalPushClient documentation, you can effectively handle push notifications and errors in your application."
What are the properties included in the FURuStoreSuccess structure?,"[' information in the Error parameter. All possible FURuStoreException errors are described in the “Error handling” section.\n\nError structure USTRUCT(BlueprintType) struct RUSTORECORE_API FURuStoreError {\n\nGENERATED_USTRUCT_BODY() FURuStoreError() {\n\nname = """"; description = """";\n\n} UPROPERTY(BlueprintReadOnly) FString name; UPROPERTY(BlueprintReadOnly) FString description;\n\n};\n\nname - error name. ● description - error description.\n\nProduct purchase\n\n395\n\nTo make a product purchase, use the PurchaseProduct() method.\n\nPurchase product request long requestId = URuStoreBillingClient::Instance()->PurchaseProduct(\n\nproductId, orderId, quantity, developerPayload, [](long requestId, TShardPtr<FURuStorePaymentResult,\n\nESPMode::ThreadSafe> response) {\n\n// Process response\n\n}, [](long requestId, TSharedPtr<FURuStoreError,\n\nESPMode::ThreadSafe> error) {\n\n// Process error\n\n}\n\n);\n\nstring productId - product identifier. ● int quantity - quantity of products. ● string developerPayload - additional information from the AnyApp developer.\n\nBlueprint implementation:\n\nThe Success callback returns a managed UE pointer (doesn\'t require manual removal) for the URuStorePaymentResultClass class in the Response parameter:\n\nPurchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStorePaymentResultClass : public UObject {\n\nGENERATED_BODY()\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY()\n\nvirtual ~FURuStorePaymentResult() {}\n\nvirtual FString GetTypeName() { return ""FURuStorePaymentResult"";\n\n} }; Purchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStoreSuccess : public URuStorePaymentResultClass {\n\nGENERATED_BODY()\n\npublic:\n\nUPROPERTY(BlueprintReadOnly)\n\n396\n\nFURuStoreSuccess value;\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStoreSuccess : public FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY() FURuStoreSuccess() {\n\norderId = """"; purchaseId = """"; productId = """"; invoiceId = """"; subscriptionToken = """";\n\n} UPROPERTY(BlueprintReadOnly) FString orderId; UPROPERTY(BlueprintReadOnly) FString purchaseId; UPROPERTY(BlueprintReadOnly) FString productId; UPROPERTY(BlueprintReadOnly) FString invoiceId; UPROPERTY(BlueprintReadOnly) FString subscriptionToken; virtual FString GetTypeName() override { return\n\n""FURuStoreSuccess""; } }; Purchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStoreCancelled : public URuStorePaymentResultClass {\n\nGENERATED_BODY()\n\npublic:\n\nUPROPERTY(BlueprintReadOnly) FURuStoreCancelled value;\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStoreCancelled : public FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY() FURuStoreCancelled() {\n\npurchaseId = """";\n\n} UPROPERTY(BlueprintReadOnly)\n\n397\n\nFString purchaseId; virtual FString GetTypeName() override { return\n\n""FURuStoreCancelled""; } }; Purchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStoreFailure : public URuStorePaymentResultClass {\n\nGENERATED_BODY()\n\npublic:\n\nUPROPERTY(BlueprintReadOnly) FURuStoreFailure value;\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStoreFailure : public FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY()\n\npublic:\n\nFURuStoreFailure() {\n\npurchaseId = """"; invoiceId = """"; orderId = """";']","The properties included in the FURuStoreSuccess structure are: orderId, purchaseId, productId, invoiceId, subscriptionToken.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The properties included in the FURuStoreSuccess structure are:
1. orderId (FString)
2. purchaseId (FString)
3. productId (FString)
4. invoiceId (FString)
5. subscriptionToken (FString)

These properties are all marked as BlueprintReadOnly, meaning they are read-only properties in the structure.","The properties included in the FURuStoreSuccess structure are:

1. orderId: A string property that represents the order ID of the successful purchase.
2. purchaseId: A string property that represents the purchase ID of the successful purchase.
3. productId: A string property that represents the product ID of the successful purchase.
4. invoiceId: A string property that represents the invoice ID of the successful purchase.
5. subscriptionToken: A string property that represents the subscription token of the successful purchase.

These properties provide detailed information about a successful purchase transaction in the URuStoreSuccess structure."
How is the security token generated and verified in the response process?,"['false — for\n\ncurrentPeriod HOLD and/or state = CLOSED.\n\nExample:\n\n""code"":""200"",\n\n""message"":""something"",\n\n""timestamp"":""2023-08-02T10:11:04.655684723+03:00"",\n\n""body"":\n\n{\n\n""is_active"": ""true""\n\n}\n\nResponse verification\n\nThe security token is generated by the security token method and then verified while getting the response:\n\nOwner and/or app should not be blocked; ● Token should be valid;\n\n973\n\nThe invoice in application_code response should contain the application code which\n\ncorresponds to the token owner.\n\nConfirming subscription\n\nThe method allows confirming subscription using a subscription token.\n\nSubscriptions do not need to be confirmed to work.\n\nInteraction parameters\n\nFor real payments: GET\n\nUnset\n\nhttps://public-api.rustore.ru/public/glike/subscription/{packageName}/{subs\n\ncriptionId}/{purchaseToken}:acknowledge\n\nFor test payments: GET\n\nUnset\n\nhttps://public-api.rustore.ru/public/sandbox/subscription/{packageName}/{su\n\nbscriptionId}/{purchaseToken}:acknowledge\n\nIf you want to work with Test Payments and Subscriptions, you\'ll need to create a new key, and when you create the key, you\'ll need to specify the methods to test.\n\nAttribute\n\nType\n\nDescription\n\nRequired\n\nLocation\n\nExample\n\nPublic-Token\n\nstring\n\nJwe token to\n\nPublic API\n\nRustore\n\nSuccessful response\n\nIn case of a successful response, the response body is empty.\n\n974\n\nError parameters\n\nAttribute\n\nType\n\nDescription\n\nRequired\n\nExample\n\ncode\n\nstring\n\nResponse\n\nYes\n\nERROR\n\ncode\n\nmessage\n\nstring\n\nDecoded\n\nNo\n\nJwe token is expired\n\nresponse\n\ncode\n\nbody{}\n\nobject\n\nResponse\n\nNo\n\nN/A\n\nbody\n\ntimestamp\n\nstring\n\nResponse\n\nYes\n\n2024-01-21T13:34:31.067240345\n\ntime\n\n+03:00\n\nError response\n\nUnset\n\n{\n\n""code"": ""ERROR"",\n\n""message"": ""Jwe token is expired"",\n\n""body"": null,\n\n""timestamp"": ""2024-01-21T13:51:59.654427798+03:00""\n\n}\n\n975\n\nResponse verification\n\nThe security token is generated by the security token method and then verified while\n\ngetting the response:\n\nOwner and/or app should not be blocked;\n\nToken should be valid;\n\nsubscription should be purchased in an application owned by a company that has\n\nreceived a Public API access token.\n\nUploading and Publishing Apps using the RuStore API\n\n1. To publish an app, follow these steps:\n\n\n\nFirst create a draft version with all the necessary app info using the Create Draft Version method.\n\nUpload an APK file via the Upload APK file method. - Upload the required images, including the app icon and screenshots, using the Upload application icon and Upload screenshots methods.\n\n2. Drafts cannot be edited, though they can be deleted using the Delete Draft method.\n\n3. After filling out all the information, the version can be sent for review via the “Submitting\n\na draft app release for review” method.\n\n4. Get a list of app versions, their basic information and status via the “Getting app version\n\nstatus” method.\n\n5. Change publication settings (publication type, date for delayed publication, and % for\n\npartial publication) via the “Change publication settings” method.\n\n6. Once you get your app reviewed and select the publication type - manual, you can\n\npublish the version using the “Manual publication” method.\n\nPlease note that you must have at least 1 active app release on the RuStore Console to start using the RuStore API.\n\n976\n\nCreating a draft release\n\nUsing this method you can create a draft app release and fill it with basic info.\n\nLimitations:\n\nYou can only create one draft per app. Attempting to create multiple drafts will result\n\nin an error;\n\ndrafts submitted via the API are not displayed in the web version of the RuStore']","The security token is generated by the security token method and then verified while getting the response. The owner and/or app should not be blocked, and the token should be valid. Additionally, the invoice in the application_code response should contain the application code corresponding to the token owner.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The security token is generated using the security token method, which allows you to generate a JWE token using a private key obtained on the RuStore Console. The method also checks the app owner's activities. 

To verify the security token in the response process, the following steps should be taken:
1. The owner and/or app should not be blocked.
2. The token should be valid.
3. The invoice in the application_code response should contain the application code which corresponds to the token owner.

Additionally, when generating the security token, it is important to include the necessary attributes such as companyId, keyId, timestamp, and signature in the request. The signature should be a SHA-512 hash in a line that contains companyId and timestamp of a response, following the verification algorithm SHA512withRSA.

Therefore, the security token is both generated and verified based on specific parameters and verification algorithms outlined in the provided documentation.","The security token, also known as the JWE token, is generated and verified in the response process using a private key obtained from the RuStore Console. Here is a detailed explanation of how the security token is generated and verified:

### Generating the Security Token:
1. **Private Key:** A private key is required to generate the JWE token.
2. **Request Parameters:**
   - `companyId`: Company ID for which the token is being generated.
   - `timestamp`: Current timestamp in the format `YYYY-MM-DDTHH:MM:SS.MMM+HH:MM`.
   - `signature`: RSA-signature SHA-512 hash containing the companyId and timestamp of the response.

3. **Algorithm:**
   - The signature is generated using the SHA512withRSA algorithm.
   - The signature is a hash of the companyId and timestamp.

4. **Token Validity:**
   - The generated JWE token is valid for 900 seconds (15 minutes) by default.
   - After the token expires, it needs to be obtained again by repeating the token generation process.

### Verifying the Security Token:
1. **Verification Process:**
   - The JWE token is sent in the response body after a successful token generation request.
   - The token is used to access the capabilities of the RuStore API.
   - The token value must be transferred to the ""Authorization"" section using the API key for authentication.

2. **Token Expiry:**
   - The token validity period is 900 seconds.
   - After the token expires, a new token must be obtained by repeating the token generation process.

### Additional Information:
- If there are issues understanding the signature parameter algorithm, a companyId jar file or a keyId jar file can be used to generate the signature parameter.
- The generated signature parameter is valid for 1 minute and directly depends on the timestamp provided in the request.

By following these steps and using the private key obtained from the RuStore Console, developers can securely generate and verify the JWE security token for accessing the RuStore API."
How can you set global configuration settings for the Maps Mobile SDK?,"['""\n\n}\n\n} } }\n\nYou should also specify the dependency in the gradle file, as shown in the example.\n\nDependency injection\n\nimplementation(\'ru.rustore.geo:mapkit:x.x.x\') where x.x.x — SDK version.\n\nWe recommend using the latest SDK version. Release versions of SDK are numbered 1.0.x\n\nThe latest SDK version is available at: https://github.com/geors?tab=packages&repo_name=maps-sdk-android\n\n872\n\nHow to use Maps Mobile SDK\n\nIt is required to initialize the card global settings before using any other SDK component, the best option is in the Application class successor. The global settings object is:\n\nclass MapViewConfig(\n\nval apiKey: String, // unique key to grant access to SDK\n\n)\n\ninstall the object:\n\nMapGlobalConfig.setMapGlobalConfig(\n\nMapViewConfig(\n\napiKey = apiKey\n\n)\n\n)\n\nTo start working with SDK, a number of classes are provided that implement View in one form or another:\n\ndata class MapStartOptions(\n\nval center: LatLon, // initial map location point (only for\n\nlat, lon)\n\nval zoomLevel: Float, // initial zoom level (zoomLevel)\n\nval style: MapStyle, // map style, you can select the\n\ncorresponding enum or use your own\n\nval compassLocationMode: CompassLocationMode, // compass\n\nsetting, can be selected from the corresponding enum\n\nval logoConfig: LogoConfig // logo configuration\n\n)\n\nYou need to set the start settings as shown in the example.\n\nMapGlobalConfig.setMapStartOptions(MapStartOptions(...))\n\nLogoConfig example\n\n873\n\ndata class LogoConfig(\n\nval logoAlignment: Alignment, // Alignment: BottomRight,\n\nBottomLeft, TopRight, TopLeft\n\nval logoAdditionalPaddings: AdditionalPaddings\n\n)\n\nTo work with the SDK, a number of classes are provided that implement View in one form or another:\n\nMapView is the main view in the SDK that displays the map; - - CurrentLocationView is a button to focus the map on the current user position and follow his position;\n\nCompassView is a component that displays the direction of a physical device relative to\n\nthe north.\n\nTo display these controls, you must place them in the xml file.\n\n<FrameLayout\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.rustore.geo.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n</FrameLayout>\n\nMap example\n\n<FrameLayout\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.mail.maps.sdk.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n874\n\n</FrameLayout>\n\nThis may be enough to work with the map if other elements are not required.\n\nConrols example\n\n<FrameLayout\n\nxmlns:custom=""http://schemas.android.com/apk/res-auto""\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.rustore.geo.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n<ru.rustore.geo.views.ZoomView\n\nandroid:id=""@+id/zoomView""\n\nandroid:layout_width=""wrap_content""\n\nandroid:layout_height=""wrap_content""\n\n...\n\ncustom:mapView=""@+id/mapView"" />\n\n<ru.rustore.geo.views.CompassView\n\nandroid:layout_width=""wrap_content""']","To set global configuration settings for the Maps Mobile SDK, you need to initialize the MapViewConfig object with the apiKey and then install it using MapGlobalConfig.setMapGlobalConfig(MapViewConfig(apiKey = apiKey))",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To set global configuration settings for the Maps Mobile SDK, you need to initialize the card global settings before using any other SDK component. The best practice is to do this in the Application class successor. 

You can set the global settings object using the following steps:
1. Create a MapViewConfig object with the required information, such as the API key to grant access to the SDK.
2. Install the object using the following code:
```
MapGlobalConfig.setMapGlobalConfig(
    MapViewConfig(
        apiKey = apiKey
    )
)
```

By following these steps, you can successfully set the global configuration settings for the Maps Mobile SDK.","To set global configuration settings for the Maps Mobile SDK, you need to initialize the card global settings before using any other SDK component. The best practice is to do this in the Application class successor. 

Here are the steps to set global configuration settings:

1. Create a MapViewConfig object with the required information:
   - apiKey: A unique key to grant access to the SDK.

2. Install the object using the following code snippet:
   ```
   MapGlobalConfig.setMapGlobalConfig(
       MapViewConfig(
           apiKey = apiKey
       )
   )
   ```

By following these steps, you can successfully set the global configuration settings for the Maps Mobile SDK."
How can you subscribe to a topic for push notifications using the RuStorePushClient?,"[' Response parameter:\n\nGetProducts response pFString response\n\nresponse - current push token.\n\nThe Failure callback returns the FURuStoreError structure with the error information in the Error parameter. All possible FURuStoreException errors are described in the “Error handling” section.\n\nError structure USTRUCT(BlueprintType) struct RUSTORECORE_API FURuStoreError {\n\nGENERATED_USTRUCT_BODY() FURuStoreError() {\n\nname = """"; description = """";\n\n} UPROPERTY(BlueprintReadOnly) FString name; UPROPERTY(BlueprintReadOnly) FString description;\n\n};\n\nname - error name. ● description - error description.\n\nUser\'s push token deletion\n\nAfter the library is initialized you can use RuStorePushClientt::Instance()->DeleteToken() to delete the user\'s current push token.\n\nRuStorePushClient.DeleteToken implementation example long responseId = URuStorePushClient::Instance()->DeleteToken(\n\n[](long responseId) {\n\n// Process success\n\n},\n\n430\n\n[](long responseId, TSharedPtr<FURuStoreError,\n\nESPMode::ThreadSafe> error) {\n\n// Process error\n\n}\n\n);\n\nBlueprint implementation:\n\nThe Failure callback returns the FURuStoreError structure with the error information in the Error parameter. All possible FURuStoreException errors are described in the “Error handling” section.\n\nError structure USTRUCT(BlueprintType) struct RUSTORECORE_API FURuStoreError {\n\nGENERATED_USTRUCT_BODY() FURuStoreError() {\n\nname = """"; description = """";\n\n} UPROPERTY(BlueprintReadOnly) FString name; UPROPERTY(BlueprintReadOnly) FString description;\n\n};\n\nname - error name. ● description - error description.\n\nMethods for working with push topics\n\nTopic-based subscription for push notifications\n\nAfter the library is initialized you can use URuStorePushClientt::Instance()->SubscribeToTopic() to subscribe to a topic.\n\nRuStorePushClient.GetToken implementation example long requestId = URuStorePushClient::Instance()->SubscribeToTopic(\n\ntopicName, [](long requestId) { // Process error }, [](long requestId, TSharedPtr<FURuStoreError,\n\nESPMode::ThreadSafe> error) {\n\n// Process error }\n\n);\n\nBlueprint implementation:\n\n431\n\nThe Failure callback returns the FURuStoreError structure with the error information in the Error parameter. All possible FURuStoreException errors are described in the “Error handling” section.\n\nError structure USTRUCT(BlueprintType) struct RUSTORECORE_API FURuStoreError {\n\nGENERATED_USTRUCT_BODY() FURuStoreError() {\n\nname = """"; description = """";\n\n} UPROPERTY(BlueprintReadOnly) FString name; UPROPERTY(BlueprintReadOnly) FString description;\n\n};\n\nname - error name. ● description - error description.\n\nUnsubscribing from topic-based push notifications\n\nAfter the library is initialized you can use RuStorePushClientt::Instance()->UnsubscribeToTopic() to unsubscribe from a topic.\n\nRuStorePushClient.DeleteToken implementation example long responseId = URuStorePushClient::Instance()->UnsubscribeFromTopic(\n\n[](long responseId) {\n\n// Process success\n\n}, [](long responseId, TSharedPtr<FURuStoreError,\n\nESPMode::ThreadSafe> error) {\n\n// Process error\n\n}\n\n);\n\nBlueprint implementation:\n\nThe Failure callback returns the FURuStoreError structure with the error information in the Error parameter. All possible FURuStoreException errors are described in the “Error handling” section.\n\nError structure USTRUCT(BlueprintType) struct RUSTORECORE_API FURuStoreError {\n\nGENERATED_USTRUCT_BODY() FURuStoreError() {\n\n432\n\nname = """"; description = """";\n\n} UPROPERTY(BlueprintReadOnly) FString name; UPROPERTY(BlueprintReadOnly) FString description;\n\n};\n\nname - error name. ● description - error description.\n\nCreation of a notification channel\n\nFor a channel']",You can subscribe to a topic for push notifications using the RuStorePushClient by calling the SubscribeToTopic() method after initializing the library. This method takes the topic name as a parameter and includes success and error callbacks for handling the subscription process.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To subscribe to a topic for push notifications using the RuStorePushClient, you can use the `SubscribeToTopic(""your_topic_name"")` method. 

In the first document on page 439, the code snippet shows how to subscribe to a topic:
```
RuStorePushClient.Instance.SubscribeToTopic(
    topicName: ""your_topic_name"",
    onFailure: (error) => {
        // Process error
    },
    onSuccess: () => {
        // Process success
    }
);
```

In the second document on page 468, the code snippet demonstrates the subscription process as well:
```
RuStorePushClient.INSTANCE.subscribeToTopic(""your_topic_name"").addOnCompleteListener(new OnCompleteListener<Void>() {
    @Override
    public void onComplete(Task<Void> task) {
        if (task.isSuccessful()) {
            // Process subscribe success
        } else {
            Exception exception = task.getException();
            // Process subscribe error
        }
    }
});
```

These code snippets show how you can subscribe to a topic for push notifications using the RuStorePushClient by providing the topic name and handling success or failure scenarios accordingly.","To subscribe to a topic for push notifications using the RuStorePushClient, you can follow the steps outlined in the documentation:

1. After the library is initialized, you can use the following method to subscribe to a topic:
   ```
   long requestId = URuStorePushClient::Instance()->SubscribeToTopic(
       topicName,
       [](long requestId) {
           // Process success
       },
       [](long requestId, TSharedPtr<FURuStoreError, ESPMode::ThreadSafe> error) {
           // Process error
       }
   );
   ```

2. In the above code snippet:
   - Replace `topicName` with the name of the topic you want to subscribe to.
   - The first lambda function handles the success scenario after subscribing to the topic.
   - The second lambda function handles any errors that may occur during the subscription process.

3. For Blueprint implementation, the Failure callback returns the `FURuStoreError` structure with the error information in the `Error` parameter. All possible `FURuStoreException` errors are described in the ""Error handling"" section of the documentation.

4. The `FURuStoreError` structure contains the following fields:
   - `name`: Error name.
   - `description`: Error description.

5. By following these steps, you can successfully subscribe to a topic for push notifications using the RuStorePushClient.

If you need further assistance or more details, feel free to ask!"
What type of data source contains HTML canvas content?,"["".\n\nVideoSource\n\nThe data source which contains the video.\n\nsrc/source/video_source.js\n\nExample: // add to map\n\nmap.addSource('some id', {\n\ntype: 'video',\n\nurl: [\n\n'path-to-video.mp4',\n\n'path-to-video.webm'\n\n],\n\ncoordinates: [\n\n[-76.54, 39.18],\n\n[-76.52, 39.18],\n\n[-76.52, 39.17],\n\n[-76.54, 39.17]\n\n]\n\n});\n\n// update\n\nvar mySource = map.getSource('some id');\n\nmySource.setCoordinates([\n\n[-76.54335737228394, 39.18579907229748],\n\n[-76.52803659439087, 39.1838364847587],\n\n763\n\n[-76.5295386314392, 39.17683392507606],\n\n[-76.54520273208618, 39.17876344106642]\n\n]);\n\nmap.removeSource('some id'); // remove\n\nMethods\n\nName\n\nDescription\n\ngetVideo()\n\nReturns an HTML video\n\npause()\n\nSets a video pause\n\nplay()\n\nContinues video playback\n\nsetCoordinates()\n\nSets video coordinates and re-renders the map\n\nImageSource\n\nImage data source\n\nsrc/source/image_source.js\n\nExample: // add to map\n\nmap.addSource('some id', {\n\ntype: 'image',\n\nurl: 'foo.png',\n\ncoordinates: [\n\n[-76.54, 39.18],\n\n[-76.52, 39.18],\n\n[-76.52, 39.17],\n\n[-76.54, 39.17]\n\n]\n\n});\n\n// update coordinates\n\nvar mySource = map.getSource('some id');\n\nmySource.setCoordinates([\n\n[-76.54335737228394, 39.18579907229748],\n\n[-76.52803659439087, 39.1838364847587],\n\n[-76.5295386314392, 39.17683392507606],\n\n764\n\n[-76.54520273208618, 39.17876344106642]\n\n]);\n\n// update url and coordinates simultaneously\n\nmySource.updateImage({\n\nurl: 'bar.png',\n\ncoordinates: [\n\n[-76.54335737228394, 39.18579907229748],\n\n[-76.52803659439087, 39.1838364847587],\n\n[-76.5295386314392, 39.17683392507606],\n\n[-76.54520273208618, 39.17876344106642]\n\n]\n\n})\n\nmap.removeSource('some id'); // remove\n\nMethods\n\nName\n\nDescription\n\nsetCoordinates(coordinates)\n\nSets the image coordinates and re-renders the map.\n\nupdateImage(options)\n\nUpdates the URL — image address and coordinates (optionally ). To avoid image flicker, set the raster-fade-duration property to 0.\n\nOptions url:string — Image URL coordinates:Array<Array<number>> — four coordinates, represented as arrays of longitude and latitude numbers, that define the image corners. The coordinates start at the top left corner of the image and go clockwise.\n\nCanvasSource\n\nThe data source contains the HTML canvas content. src/source/canvas_source.js\n\nExample: // add to map\n\nmap.addSource('some id', {\n\ntype: 'canvas',\n\ncanvas: 'idOfMyHTMLCanvas',\n\nanimate: true,\n\ncoordinates: [\n\n765\n\n[-76.54, 39.18],\n\n[-76.52, 39.18],\n\n[-76.52, 39.17],\n\n[-76.54, 39.17]\n\n]\n\n});\n\n// update\n\nvar mySource = map.getSource('some id');\n\nmySource.setCoordinates([\n\n[-76.54335737228394,""]",CanvasSource contains HTML canvas content.,simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The type of data source that contains HTML canvas content is a ""canvas"" source type. This type of data source is specifically designed to handle HTML canvas content within the map. It allows developers to interact with and manipulate canvas elements on the map, enabling features like animation and static image display.","The type of data source that contains HTML canvas content is called CanvasSource. The CanvasSource is used to add HTML canvas content to the map. It allows for interactive elements and animations to be displayed on the map. The CanvasSource has methods such as getCanvas(), pause(), play(), and setCoordinates() to work with the HTML canvas content. Additionally, the CanvasSourceOptions specify the parameters required to add a canvas source type to the map, including the type, canvas, coordinates, and animate properties."
How does the resample distance parameter affect the height values returned in the response for the specified coordinates?,"[']\n\n]\n\n}\n\n895\n\nresample _distance\n\nInteger\n\nValue in meters to indicate the distance between the height points. The original route from successive points is divided into segments such as resample_dist ance. This service returns the points formed in this way and the height values for these points. Use case examples: it is required to build an elevation profile in a user route with heights at a 50 m distance from each other. Default value: no field, the service returns one height value per specified coordinate.\n\n{\n\n""resample_distance"" :10000,\n\n""locations"":[\n\n{\n\n""lat"":55.601897,\n\n""lon"":37.581305 }, {\n\n""lat"":55.885040,\n\n""lon"":37.680869\n\n}\n\n]\n\n}\n\n{\n\n""locations"":[\n\n{\n\n""lat"":55.601897,\n\n""lon"":37.581305 }, {\n\n""lat"":55.690027,\n\n""lon"":37.612137 }, {\n\n""lat"":55.778150,\n\n""lon"":37.643109 }, {\n\n""lat"":55.866264,\n\n""lon"":37.674221 }, {\n\n""lat"":55.885040,\n\n""lon"":37.680869\n\n}\n\n], ""range_height"":[\n\n[\n\n0, 201\n\n], [\n\n10000, 143\n\n], [\n\n20000, 161\n\n],\n\n896\n\n[\n\n30000, 151\n\n], [\n\n32131, 139\n\n]\n\n]\n\n}\n\nheight_pr ecision\n\nInteger\n\nNumber of decimal places in the height value. Fractional height values may be required, for example, for greater accuracy and smoothness in the elevation profile. Possible values: 0-2. Default value: 0 (height is an integer).\n\n{\n\n""height_precision"": 2,\n\n""locations"":[\n\n{\n\n""lat"":55.601897,\n\n""lon"":37.581305 }, {\n\n""lat"":55.885040,\n\n{\n\n""locations"":[\n\n{\n\n""lat"":55.601897,\n\n""lon"":37.581305 }, {\n\n""lat"":55.885040,\n\n""lon"":37.680869\n\n}\n\n""lon"":37.680869\n\n}\n\n]\n\n], ""height"":[ 200.94, 138.84\n\n}\n\n]\n\n}\n\nResponse\n\nIf height cannot be determined for some point, null is returned instead of a value in meters.\n\nField name\n\nFormat\n\nDescription\n\nExample\n\n897\n\nlocations Response field format matches the format selected for the request\n\nheight\n\nHeight array\n\nThis field returns the coordinates for which the height was requested.\n\nThis field will be present in the response if ""range"":true is not specified in the request. If the ""resample_distance"" field is not specified in the request, the number of values in the ""height"" array is the same as the number of points passed in the request. If the ""resample_distance"" field is specified, then the number of heights corresponds to the number of points on the locations polyline, between which the distance is equal to ""resample_distance""\n\n""list of coordinates"" format:\n\n""locations"":[ {\n\n""lat"":55.601897,\n\n""lon"":37.581305 }, {\n\n""lat"":55.885040,\n\n""lon"":37.680869\n\n}\n\n]\n\n""encoded string"" format:\n\n""s{cplAfiz{pCa]xBxBx`Ah C|gApBrz@{[h...""\n\n""string"" format:\n\n152.2, 34.8|158.8, 23.0|120.0, 10.0\n\n""height"":[221,172,206,1 88,153]\n\n898\n\nrange_h eight\n\nAn array of x and y value pairs: x - total distance in meters from the route start. For the first coordinate it is always 0 m y - height in meters for the coordinate at the given index\n\nThis field is present in the response if ""range"":true is specified in the request. The number of pairs in the ""range_height"" array is determined by the same rules as in the ""']","The resample distance parameter affects the height values returned in the response by dividing the original route from successive points into segments based on the specified distance. The service then returns the points formed in this way and the corresponding height values. If the resample distance is set, the number of heights corresponds to the number of points on the locations polyline, between which the distance is equal to the resample distance.",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The resample distance parameter in the request affects the height values returned in the response by determining the distance between the height points. When the resample distance is specified in the request, the original route from successive points is divided into segments based on this distance. The service then returns the points formed in this way and the corresponding height values for these points.

If the resample distance is not specified in the request, the service returns one height value per specified coordinate. However, if the resample distance is specified, the number of height values returned corresponds to the number of points on the locations polyline, between which the distance is equal to the resample distance.

Therefore, by adjusting the resample distance parameter in the request, developers can control the granularity of the height values returned in the response for the specified coordinates.","The ""resample_distance"" parameter affects the height values returned in the response by determining the distance between the height points. 

When the ""resample_distance"" field is specified in the request, the number of heights corresponds to the number of points on the locations polyline, between which the distance is equal to the specified ""resample_distance"". This means that the height values returned in the response will be calculated based on the specified distance between the points, providing a more detailed and accurate representation of the elevation profile along the specified coordinates.

If the ""resample_distance"" field is not specified in the request, the number of values in the ""height"" array will be the same as the number of points passed in the request without any resampling based on distance.

Therefore, by adjusting the ""resample_distance"" parameter in the request, you can control the level of detail and granularity of the height values returned in the response for the specified coordinates."
How to extract project ID from RuStore Console for push notifications setup with URL and segment page info?,"[' the URL after navigating to the\n\nsegment page.\n\nCopy the idSegment from the url and use it in the request:\n\ncurl --location\n\n\'https://segments-vkpns.rustore.ru/v1/export_settings/project/<e\n\nxport_project_id>/segments/create\' \\\n\n--header \'Content-Type: application/json\' \\\n\n--header \'Accept: application/json\' \\\n\n--header \'Authorization: Bearer <ss_token>\' \\\n\n--data \'{\n\n""period"": 24,\n\n""segment"": ""<mt_segment_id>""\n\n}\';\n\nexport_project_id: This is the project ID obtained during the initial setup.\n\nmt_segment_id: This is the segment ID acquired from MyTracker.\n\n494\n\nss_token: This is the service token used for authorization, obtained from the RuStore Console on the push notifications project page.\n\nRuStore General Push Notifications SDK\n\nKotlin\n\nGeneral\n\nGoogle Play Huawei Mobile Services\n\nInitialization Push notifications functional check Tokens Topics Handling notifications If HMS/FCM are already in use\n\n256 260 262 265 267 268 270 271 274\n\n495\n\nGeneral\n\nRuStore General Push Notifications SDK is a set of packages which are required to operate with push notifications. You can send and receive messages via multiple channels:\n\nFCM — Firebase Cloud Messaging; ● HMS — Huawei Mobile Services; ● RuStore.\n\nUse SDK together with pre-configured HMS and FCM.\n\nImplementation example\n\nCheck out the example app to learn how to integrate universal push notifications properly.\n\nConditions for correct operation of SDK\n\nFor general push notifications SDK to operate correctly, the following conditions need to be met:\n\nThe RuStore app must be installed on the user\'s device. ● The RuStore app must support push notifications. ● The RuStore app is allowed access to work in the background. ● The user has logged in to the RuStore. ● The app signature must match the one added to the Developer Console.\n\nSetting up the app\n\nTo initialize your app, you will need a project ID, which can be obtained from the RuStore Console. On the app page, go to Push Notifications and then select Projects.\n\n496\n\nImporting SDK to your project\n\nConnect the repository in settings.gradle:\n\ndependencyResolutionManagement {\n\nrepositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n\nrepositories {\n\ngoogle()\n\nmavenCentral()\n\nmaven {url = uri(""https://developer.huawei.com/repo/"")}\n\nmaven {\n\nurl =\n\nuri(""https://artifactory-external.vkpartner.ru/artifactory/maven"")\n\n}\n\n}\n\n}\n\nDependency injection\n\nAdd the following code to your build.gradle to inject the dependency at the app level:\n\ndependencies {\n\n497\n\nimplementation \'ru.rustore.sdk:universalpush:1.0.0\' implementation \'ru.rustore.sdk:universalrustore:1.0.0\' implementation \'ru.rustore.sdk:universalhms:1.0.0\' implementation \'ru.rustore.sdk:universalfcm:1.0.0\'\n\n}\n\nAdd the following rule when using the SDK in your app along with ProGuard:\n\nkeep public class com.vk.push.** extends android.os.Parcelable\n\nFollow the steps below to work with FCM and HMS:\n\nadd to build.gradle at the app level\n\nplugins {\n\n// ...\n\n// required for fcm id \'com.google.gms.google-services\' // required for hms id \'com.huawei.agconnect\'\n\n}\n\nadd to build.gradle at the root level\n\ndependencies { // for fcm classpath \'com.google.gms:google-services:4.3.15\' // for hms classpath \'com.huawei.agconnect:agcp:1.6.0.300\' classpath \'com.android.tools.build:gradle:7.4.0\'\n\n}\n\nadd to settings.gradle at the root level\n\npluginManagement {\n\nrepositories {\n\ngoogle()\n\nmavenCentral()\n\ngradlePluginPortal()\n\n// required for']","To extract the project ID from the RuStore Console for push notifications setup, go to the app page, navigate to Push Notifications, and then select Projects.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To extract the project ID from RuStore Console for push notifications setup, you can follow these steps:

1. Go to the RuStore Console.
2. Navigate to the ""Push Notifications"" section.
3. Click on the ""Projects"" subsection.
4. In this section, you will be able to find the project ID needed for setting up push notifications.
5. Additionally, for sending push notifications with URL and segment page info, you can use the following URL and API endpoint:
   - URL: https://vkpns.rustore.ru/v1/projects/$project_id/messages:send
   - API Endpoint: https://vkpns.rustore.ru/v1/projects/$project_id/messages:send

By following these steps and using the provided URL and API endpoint, you can extract the project ID from RuStore Console and set up push notifications with URL and segment page info.","To extract the project ID from the RuStore Console for setting up push notifications, follow these steps:

1. Go to the RuStore Console.
2. Navigate to the ""Push Notifications"" section.
3. Select the ""Projects"" option.
4. Look for the project ID associated with your app in the list of projects.

Additionally, to set up push notifications with URL and segment page information, you will need the following items:

- project_id (project ID)
- ss_token (service token)

These values can be obtained in the RuStore Console as mentioned above. Once you have the project ID and service token, you can proceed with setting up push notifications and managing segments for targeted messaging to specific groups of users."
How to set up push notification providers in the app and verify their availability and receive tokens?,"[' below to work with HMS: ● add to build.gradle at the app level\n\nplugins {\n\n// ...\n\n// required for hms id \'com.huawei.agconnect\'\n\n}\n\nadd to build.gradle at the root level\n\ndependencies {\n\n// for hms\n\nclasspath \'com.huawei.agconnect:agcp:1.6.0.300\'\n\nclasspath \'com.android.tools.build:gradle:7.4.0\'\n\n}\n\nadd to settings.gradle at the root level\n\npluginManagement { repositories {\n\ngoogle() mavenCentral() gradlePluginPortal() // required for hms maven {url = uri(""https://developer.huawei.com/repo/"")}\n\n}\n\n}\n\n503\n\nInitialization\n\nTo initialize your app, you need to add the following code to App.kt:\n\nimport android.app.Application import ru.rustore.sdk.universalpush.RuStoreUniversalPushClient import ru.rustore.sdk.universalpush.firebase.provides.FirebasePushProvider import ru.rustore.sdk.universalpush.hms.providers.HmsPushProvider import ru.rustore.sdk.universalpush.rustore.logger.DefaultLogger import ru.rustore.sdk.universalpush.rustore.providers.RuStorePushProvider\n\nclass App: Application() {\n\nprivate val tag = ""UniversalPushExampleApp""\n\noverride fun onCreate() { super.onCreate()\n\nRuStoreUniversalPushClient.init(\n\ncontext = this, rustore = RuStorePushProvider(\n\napplication = this, projectId = ""m3Id6aPeXq36mp..."", logger = DefaultLogger(tag = tag),\n\n), firebase = FirebasePushProvider(\n\ncontext = this,\n\n), hms = HmsPushProvider( context = this, appid = ""108003365"",\n\n),\n\n)\n\n}\n\n}\n\nYou need to initialize those push notification providers that are currently in use.\n\nRuStoreUniversalPushClient.init(\n\ncontext = this, rustore = RuStorePushProvider(\n\napplication = this,\n\n504\n\n)\n\nprojectId = ""m3Id6aPeXq36mp..."", logger = DefaultLogger(tag = tag),\n\n), hms = HmsPushProvider( context = this, appid = ""108003365"",\n\n),\n\n505\n\nPush notifications functional check\n\nTo check whether push notification providers are available, call the checkAvailability(context) method.\n\nRuStoreUniversalPushClient.checkAvailability(this)\n\n.addOnCompleteListener(object :\n\nOnCompleteListener<Map<String, Boolean>> {\n\noverride fun onSuccess(result: Map<String,\n\nBoolean>) {\n\nLog.w(tag, ""get availability success\n\n${result}"")\n\n}\n\noverride fun onFailure(throwable: Throwable) { Log.e(tag, ""get tokens err: ${throwable}"")\n\n}\n\n})\n\nresult — dictionary with keys:\n\npublic const val UNIVERSAL_FCM_PROVIDER: String = ""firebase"" public const val UNIVERSAL_HMS_PROVIDER: String = ""hms"" public const val UNIVERSAL_RUSTORE_PROVIDER: String = ""rustore""\n\nTo check the availability of a specific push notification provider:\n\nif (result[UNIVERSAL_HMS_PROVIDER] ?: false) {\n\n// hms provider is available\n\n}\n\n506\n\nTokens\n\nReceiving tokens\n\nCall the getTokens() method to get a list of tokens for all providers.\n\nRuStoreUniversalPushClient.getTokens()\n\n.addOnCompleteListener(object :\n\nOnCompleteListener<Map<String, Boolean>> {\n\noverride fun onSuccess(result: Map<String,\n\nBoolean>) {\n\nLog.w(tag, ""get availability success\n\n${result}"")\n\n}\n\noverride fun onFailure(throwable: Throwable) {\n\nLog.e(tag, ""get tokens err: ${throwable}"")\n\n}\n\n})\n\nresult — dictionary with keys:\n\npublic const val UNIVERSAL_FCM_PROVIDER: String = ""firebase"" public const val UNIVERSAL_HMS_PROVIDER: String = ""hms"" public const val UNIVERSAL_RUSTORE']","To set up push notification providers in the app, you need to add the necessary dependencies and initialization code as mentioned in the provided context. After initialization, you can verify the availability of push notification providers by calling the checkAvailability(context) method. To receive tokens for all providers, you can call the getTokens() method.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To set up push notification providers in the app and verify their availability, you can follow these steps:

1. **Setting Up Push Notification Providers:**
   - Use the `ruStorePush.set_on_token()` method to receive push tokens from users. If a user does not have a push token, this method will return a new push token.
   - Implement a callback function to handle token retrieval. For example:
     ```lua
     local function new_token(self, token, error)
       if token then
         print(token)
       else
         print(error.error)
       end
     end
     ruStorePush.set_on_token(new_token)
     ```
   - Use the `ruStorePush.set_on_message()` method to work with push messages. Implement a callback function to handle incoming push notifications. For example:
     ```lua
     local function listener(self, payload, activated)
       -- Handle the payload here
       pprint(payload)
     end
     ruStorePush.set_on_message(listener)
     ```

2. **Verifying Push Notification Providers Availability:**
   - To check the availability of push notification providers, you can use the `RuStoreUniversalPushClient.checkAvailability(this)` method.
   - Implement the `addOnCompleteListener` with `OnCompleteListener<Map<String, Boolean>>` to handle the success and failure cases. For example:
     ```java
     RuStoreUniversalPushClient.checkAvailability(this)
       .addOnCompleteListener(object : OnCompleteListener<Map<String, Boolean>> {
         override fun onSuccess(result: Map<String, Boolean>) {
           Log.w(tag, ""get availability success ${result}"")
         }
         override fun onFailure(throwable: Throwable) {
           Log.e(tag, ""get tokens err: ${throwable}"")
         }
       })
     ```
   - The `result` dictionary will contain keys for different push notification providers like `UNIVERSAL_FCM_PROVIDER`, `UNIVERSAL_HMS_PROVIDER`, and `UNIVERSAL_RUSTORE_PROVIDER`. You can check the availability of a specific provider using these keys.

By following these steps, you can set up push notification providers in your app, verify their availability, receive push tokens, and handle push messages effectively.","To set up push notification providers in your app and verify their availability, as well as receive tokens, you can follow the steps outlined in the RuStore developers documentation.

1. **Initialization of Push Notification Providers**:
   - Initialize the RuStoreUniversalPushClient with the necessary parameters for each push notification provider. For example, for RuStore, you need to provide the project ID, and for HMS (Huawei Mobile Services), you need to provide the app ID.
   - Example code snippet for initialization:
     ```kotlin
     RuStoreUniversalPushClient.init(
         context = this,
         rustore = RuStorePushProvider(
             application = this,
             projectId = ""m3Id6aPeXq36mp...""
         ),
         logger = DefaultLogger(tag = tag),
         hms = HmsPushProvider(
             context = this,
             appid = ""108003365""
         )
     )
     ```

2. **Verifying Provider Availability**:
   - To check the availability of push notification providers, you can call the `checkAvailability(context)` method. This method will return a dictionary with keys indicating the availability of each provider.
   - Example code snippet to check availability:
     ```kotlin
     RuStoreUniversalPushClient.checkAvailability(this)
         .addOnCompleteListener(object : OnCompleteListener<Map<String, Boolean>> {
             override fun onSuccess(result: Map<String, Boolean>) {
                 if (result[UNIVERSAL_HMS_PROVIDER] ?: false) {
                     // HMS provider is available
                 }
             }

             override fun onFailure(throwable: Throwable) {
                 Log.e(tag, ""get tokens err: ${throwable}"")
             }
         })
     ```

3. **Receiving Tokens**:
   - To receive tokens for all providers, you can call the `getTokens()` method. This method will return a dictionary with keys representing each provider's token.
   - Example code snippet to receive tokens:
     ```kotlin
     RuStoreUniversalPushClient.getTokens()
         .addOnCompleteListener(object : OnCompleteListener<Map<String, Boolean>> {
             override fun onSuccess(result: Map<String, Boolean>) {
                 Log.w(tag, ""get availability success ${result}"")
             }

             override fun onFailure(throwable: Throwable) {
                 Log.e(tag, ""get tokens err: ${throwable}"")
             }
         })
     ```

By following these steps, you can set up push notification providers in your app, verify their availability, and receive tokens for each provider."
What is the keyphrase for URuStorePaymentResultClass in error handling?,"[' information in the Error parameter. All possible FURuStoreException errors are described in the “Error handling” section.\n\nError structure USTRUCT(BlueprintType) struct RUSTORECORE_API FURuStoreError {\n\nGENERATED_USTRUCT_BODY() FURuStoreError() {\n\nname = """"; description = """";\n\n} UPROPERTY(BlueprintReadOnly) FString name; UPROPERTY(BlueprintReadOnly) FString description;\n\n};\n\nname - error name. ● description - error description.\n\nProduct purchase\n\n395\n\nTo make a product purchase, use the PurchaseProduct() method.\n\nPurchase product request long requestId = URuStoreBillingClient::Instance()->PurchaseProduct(\n\nproductId, orderId, quantity, developerPayload, [](long requestId, TShardPtr<FURuStorePaymentResult,\n\nESPMode::ThreadSafe> response) {\n\n// Process response\n\n}, [](long requestId, TSharedPtr<FURuStoreError,\n\nESPMode::ThreadSafe> error) {\n\n// Process error\n\n}\n\n);\n\nstring productId - product identifier. ● int quantity - quantity of products. ● string developerPayload - additional information from the AnyApp developer.\n\nBlueprint implementation:\n\nThe Success callback returns a managed UE pointer (doesn\'t require manual removal) for the URuStorePaymentResultClass class in the Response parameter:\n\nPurchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStorePaymentResultClass : public UObject {\n\nGENERATED_BODY()\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY()\n\nvirtual ~FURuStorePaymentResult() {}\n\nvirtual FString GetTypeName() { return ""FURuStorePaymentResult"";\n\n} }; Purchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStoreSuccess : public URuStorePaymentResultClass {\n\nGENERATED_BODY()\n\npublic:\n\nUPROPERTY(BlueprintReadOnly)\n\n396\n\nFURuStoreSuccess value;\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStoreSuccess : public FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY() FURuStoreSuccess() {\n\norderId = """"; purchaseId = """"; productId = """"; invoiceId = """"; subscriptionToken = """";\n\n} UPROPERTY(BlueprintReadOnly) FString orderId; UPROPERTY(BlueprintReadOnly) FString purchaseId; UPROPERTY(BlueprintReadOnly) FString productId; UPROPERTY(BlueprintReadOnly) FString invoiceId; UPROPERTY(BlueprintReadOnly) FString subscriptionToken; virtual FString GetTypeName() override { return\n\n""FURuStoreSuccess""; } }; Purchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStoreCancelled : public URuStorePaymentResultClass {\n\nGENERATED_BODY()\n\npublic:\n\nUPROPERTY(BlueprintReadOnly) FURuStoreCancelled value;\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStoreCancelled : public FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY() FURuStoreCancelled() {\n\npurchaseId = """";\n\n} UPROPERTY(BlueprintReadOnly)\n\n397\n\nFString purchaseId; virtual FString GetTypeName() override { return\n\n""FURuStoreCancelled""; } }; Purchase result structure UCLASS(BlueprintType) class RUSTOREBILLING_API URuStoreFailure : public URuStorePaymentResultClass {\n\nGENERATED_BODY()\n\npublic:\n\nUPROPERTY(BlueprintReadOnly) FURuStoreFailure value;\n\n}; USTRUCT(BlueprintType) struct RUSTOREBILLING_API FURuStoreFailure : public FURuStorePaymentResult {\n\nGENERATED_USTRUCT_BODY()\n\npublic:\n\nFURuStoreFailure() {\n\npurchaseId = """"; invoiceId = """"; orderId = """";']",The keyphrase for URuStorePaymentResultClass in error handling is 'FURuStorePaymentResult'.,reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The keyphrase for URuStorePaymentResultClass in error handling is ""EURuStorePaymentFinishCode."" This enum class defines different error handling scenarios such as ""SUCCESSFUL_PAYMENT,"" ""CLOSED_BY_USER,"" ""UNHANDLED_FORM_ERROR,"" ""PAYMENT_TIMEOUT,"" ""DECLINED_BY_SERVER,"" and ""RESULT_UNKNOWN.""","The keyphrase for URuStorePaymentResultClass in error handling is ""Failure callback returns the FURuStoreError structure with the error information in the Error parameter."" This indicates that when there is an error in the URuStorePaymentResultClass, the Failure callback will provide details about the error using the FURuStoreError structure in the Error parameter."
How to check and use RuStore app updates?,"[', the plugin needs to be initialized.\n\n547\n\nUnset\n\nRustoreReviewClient.init();\n\nStart the evaluation of the application\n\nAfter initialisation, you can query and display the form.\n\ntry {\n\nconst isRequested = await RustoreReviewClient.requestReviewFlow();\n\nif (isRequested) {\n\nawait RustoreReviewClient.launchReviewFlow();\n\n}\n\n} catch (err) {\n\nconsole.log(err);\n\n}\n\nPossible errors\n\nPossible errors you can get in onFailure:\n\nRuStoreNotInstalledException() — user’s device doesn’t have RuStore installed. ● RuStoreOutdatedException() — RuStore installed on a user\'s device doesn’t support the start of the rating and feedback process.\n\nRuStoreUserUnauthorizedException() — the user is not logged in to RuStore. ● RuStoreUserBannedException() — the user is blocked in RuStore. ● RuStoreApplicationBannedException() — the app is blocked in RuStore. ● RuStoreRequestLimitReached() — too little time elapsed since the last display of the process.\n\nRuStoreReviewExists() — this user has already rated your app. ● RuStoreInvalidReviewInfo() — problems with ReviewInfo.\n\n548\n\nRuStoreException(message: String) — RuStore basic error from which all the other\n\nerrors are inherited.\n\n549\n\nApp Update SDK\n\nKotlin/Java\n\nGeneral Information Importing SDK to your project Creating an Update Manager Checking for updates Downloading updates Installing updates Possible errors\n\n299 300 301 302 304 306 307\n\n550\n\nGeneral Information\n\nRuStore In-app updates SDK enable users to be kept up to date with the latest app version on their device. This allows them to stay informed about any performance enhancements or bug fixes that have been implemented.\n\nAdditionally, the SDK offers the ability to notify users of a new version and provide an option to install it. The installation process can occur in the background, while the user can track the progress of the update.\n\nUse case example\n\nConditions for correct operation of SDK\n\nFor RuStore In-app updates SDK to operate correctly, the following conditions need to be met:\n\n1. Android 6.0 or later. 2. The RuStore app is installed on the user\'s device. 3. The current RuStoreApp version is installed on the user\'s device. 4. The RuStore app is allowed to install applications.\n\n551\n\nImporting SDK to your project\n\nConnect the repository:\n\nrepositories { maven {\n\nurl =\n\nuri(""https://artifactory-external.vkpartner.ru/artifactory/maven"")\n\n}\n\n}\n\nDependency injection\n\nAdd the following code to your configuration file to inject the dependency:\n\ndependencies {\n\nimplementation(""ru.rustore.sdk:appupdate:2.0.0"")\n\n}\n\n552\n\nCreating an Update Manager\n\nBefore you start, create an update manager using the Factory method:\n\nval updateManager = RuStoreAppUpdateManagerFactory.create(context)\n\n553\n\nChecking for updates\n\nBefore requesting an update, check if it is available for your application. To check for updates, call the getAppUpdateInfo() method. When this method is called, the following conditions will be verified:\n\n1. The RuStore app is installed on the user\'s device. 2. The current RuStoreApp version is installed on the user\'s device. 3. The user and the app should not be blocked on the RuStore.\n\nUpon calling this method, an AppUpdateInfo object will be returned which contains information regarding any required updates. It is recommended to request and cache this object in advance, ensuring a prompt and convenient update download process for the user.\n\nvar appUpdateInfo: AppUpdateInfo? = null\n\nupdateManager\n\n.getAppUpdateInfo()\n\n.addOnSuccessListener { info ->\n\nappUpdateInfo = info\n\n}\n\n.addOnFailureListener { throwable ->\n\n}\n\nThe updateInfo object contains a set of parameters needed to determine if an update is available:\n\nupdateAvailability — update availability::\n\nUNKNOWN (Int == 0) — default status; ○ UPDATE_NOT_AVAILABLE (Int == 1) — no update required ○ UPDATE_AVAILABLE (Int == 2) — update needs to be downloaded or it has already been downloaded to the user\'s device.\n\nDEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS — update']","To check for updates and use RuStore app updates, you need to create an update manager using the Factory method, check for updates by calling the getAppUpdateInfo() method, and handle the AppUpdateInfo object returned. This object contains information about the update availability and status, allowing you to prompt users to download and install the latest version of your app.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To check and use RuStore app updates, you can follow these steps outlined in the provided documents:

1. Check for updates by calling the `getAppUpdateInfo()` method.
2. Verify the following conditions:
   - RuStore app is installed on the user's device.
   - Current RuStoreApp version is installed on the user's device.
   - The user has logged in to RuStore.
   - The user and the app should not be blocked on RuStore.
   - RuStore app is allowed to install applications.
3. Upon calling the `getAppUpdateInfo()` method, an `AppUpdateInfo` object will be returned, containing information regarding any required updates.
4. It is recommended to request and cache this object in advance to ensure a prompt and convenient update download process for the user.

Additionally, the `AppUpdateInfo` object contains parameters to determine update availability and installation status:
- `updateAvailability`:
  - UNKNOWN: Default status.
  - UPDATE_NOT_AVAILABLE: No update required.
  - UPDATE_AVAILABLE: Update needs to be downloaded or has already been downloaded to the user's device.
  - DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS: Update is already being downloaded or installation is already running.
- `installStatus`:
  - DOWNLOADED: Downloaded.
  - DOWNLOADING: Being downloaded.
  - FAILED: Error.
  - INSTALLING: Being installed.
  - PENDING: Waiting for download.
  - UNKNOWN: Default status.

You can use the `GetAppUpdateInfo()` method with appropriate callbacks to handle success and error responses when checking for and using RuStore app updates.","To check and use RuStore app updates, you need to follow these steps:

1. **Conditions for Correct Operation**:
   - Ensure that the user's device runs on Android 7.0 or later.
   - Make sure that RuStore is installed on the user's device.
   - Verify that the RuStoreApp version on the device is up-to-date.
   - Confirm that the user is logged in to RuStore.
   - Check that the RuStore app is authorized to install applications.

2. **Connecting to Project**:
   - Copy the contents of the “Plugins” folder from the official RuStore repository on GitHub to the “Plugins” folder of your project.
   - Restart Unreal Engine and select “RuStoreAppUpdate” and “RuStoreCore” in the plug-in list (Edit → Plugins → Project → Mobile).

3. **Update Dependencies**:
   - In the “YourProject.Build.cs” file, add the “RuStoreCore” and “RuStoreAppUpdate” modules to the PublicDependencyModuleNames list.

4. **Project Settings for Android**:
   - Set the Minimum SDK Version parameter to level 24 or later and the Target SDK Version parameter to 31 or later in the project settings (Edit → Project Settings → Android).

5. **Creating Update Manager**:
   - Before calling library methods, create an update manager by initializing it with `URuStoreAppUpdateManager::Instance()->Init();`.
   - Remember to dispose of the manager when no longer needed using `URuStoreAppUpdateManager::Instance()->Dispose();`.

6. **Checking for Updates**:
   - To check for update availability, call the GetAppUpdateInfo() method.
   - If an update is available, you can start the update installation by calling the CompleteUpdate() method.

7. **Handling Errors**:
   - If an error occurs during the update process, handle it appropriately.
   - Possible errors include RuStoreNotInstalledException, RuStoreOutdatedException, RuStoreUserUnauthorizedException, and more as listed in the documentation.

8. **Additional Information**:
   - The update process is done via the native Android tool, and if successful, the app will close.
   - It is recommended not to display errors to the user if a failure occurs to maintain a positive user experience.

By following these steps and guidelines, you can effectively check for RuStore app updates and utilize them in your project."
"What types of messages can be exchanged in an app, such as user-generated content, personal info, and communication data?","['Emails\n\nSMS or MMS\n\nOther in-app messages\n\nPhotos\n\nVideos\n\nVoice or sound recordings\n\nMusic files\n\nInformation about the user\'s political or religious beliefs.\n\nInformation about the user\'s sexual orientation.\n\nAny other personal information such as date of birth, gender identity, veteran status, etc.\n\nInformation about the user\'s financial accounts, such as credit card number.\n\nInformation about purchases or transactions the user has made.\n\nInformation about the user\'s credit. For example, the user’s credit history or credit score.\n\nAny other financial information, such as the user\'s salary or debts.\n\nInformation about the user\'s health, such as medical records or symptoms.\n\nInformation about the user\'s fitness, such as exercise or other physical activity.\n\nUser emails, including the email subject line, sender, recipients, and the content of the email.\n\nUser text messages, including the sender, recipients, and the content of the message.\n\nAny other types of messages. For example, instant messages or chat content.\n\nUser photos.\n\nUser videos.\n\nUser voice, such as a voicemail or a sound recording.\n\nUser music files.\n\n33\n\nFiles and docs\n\nCalendar\n\nContacts\n\nApp activity\n\nWeb browsing\n\nApp info and performa nce\n\nOther audio files\n\nFiles and docs\n\nCalendar events\n\nContacts\n\nApp interactions\n\nIn-app search history\n\nInstalled apps\n\nOther user-generat ed content\n\nOther actions\n\nWeb browsing history\n\nCrash logs\n\nDiagnostics\n\nAny other audio files the user created or provided.\n\nUser files or documents, or information about the user’s files or documents, such as file names.\n\nInformation from the user’s calendar, such as events, event notes, and attendees.\n\nInformation about the user’s contacts, such as contact names, message history, and social graph information like usernames, contact recency, contact frequency, interaction duration, and call history.\n\nInformation about how the user interacts with the app. For example, the number of times the user visits a page or sections the user taps on.\n\nInformation about what the user has searched for in the app.\n\nInformation about the apps installed on the user’s device.\n\nAny other content the user generated that is not listed here, or in any other section. For example, bios, notes, or open-ended responses.\n\nAny other activity or actions in-app not listed here, such as gameplay, likes, and dialog options.\n\nInformation about the websites the user has visited.\n\nCrash data from the app. For example, the number of times the app has crashed on the device or other information directly related to a crash.\n\nInformation about the performance of the app on the device. For example, battery life, loading time, latency, framerate, or any technical diagnostics.\n\n34\n\nDevice or other IDs\n\nOther app performance data\n\nDevice or other IDs\n\nAny other app performance data not listed here.\n\nIdentifiers that relate to an individual device, browser, or app. For example, an IMEI number, MAC address, Widevine Device ID, Firebase installation ID, or advertising identifier.\n\n35\n\nTypes of permissions\n\nAll the permissions that are required by your app are subject to primarily check once added to the RuStore Console.\n\nThe developer is obliged to declare all permissions, except for Normal, i.e. Dangerous, Special, Signature.\n\nThe apps that use permissions from the “Not for use by third-party applications” category will be blocked automatically.\n\nDangerous, Special and Signature permissions are considered altogether as “Dangerous permissions”.\n\nAll the available permissions are listed below.\n\nPermission levels\n\nLevel\n\nName\n\nDescription\n\nNot for use by third-party applications\n\nACCESS_CHECKIN_PROPERTIES\n\nAllows read/write access to the ""properties"" table in the checkin database, to change values that get uploaded.\n\nACCOUNT_MANAGER\n\nAllows applications to call into AccountAuthenticators.\n\nBIND_APPWIDGET\n\nAllows an application to tell the AppWidget service which application can access AppWidget\'s data.\n\nBLUETOOTH_PRIVILEGED\n\nAllows applications to pair bluetooth devices without user interaction, and to allow or disallow phonebook access or message access.\n\nBROADCAST_PACKAGE_REMOVE D\n\nAllows an application to broadcast a notification that an application package has been removed.\n\nBR']","User-generated content, personal information, and communication data can be exchanged in an app through various types of messages, including emails, text messages, in-app messages, photos, videos, voice or sound recordings, music files, and any other types of messages like instant messages or chat content.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"In an app, various types of messages can be exchanged, including user-generated content, personal information, and communication data. User-generated content can include text, images, videos, and audio files shared between users. Personal information exchanged in messages may consist of user IDs, email addresses, phone numbers, and addresses. Communication data can involve emails, SMS or MMS messages, and other in-app messages like instant messages or chat content. These types of messages facilitate interaction and information sharing within the app environment.","In an app, various types of messages can be exchanged, including:

1. **Emails**: This includes user emails, which may contain the email subject line, sender, recipients, and the content of the email.
   
2. **SMS or MMS**: User text messages can be exchanged, including the sender, recipients, and the content of the message.
   
3. **Other in-app messages**: This category covers any other types of messages exchanged within the app, such as instant messages or chat content.
   
These messages may contain a wide range of information, including user-generated content, personal information, and communication data. It's important for developers to be transparent about the types of messages being exchanged to ensure user data safety and compliance with regulations.

If you have any more questions or need further details, feel free to ask!"
How to interact with the map using touch gestures and trigger a repaint?,"[' the map using touch gestures. For more information, see TouchZoomRotateHandler\n\n696\n\ntriggerRepaint()\n\nunproject(point)\n\nupdateImage(id, image)\n\nversion\n\nzoomIn(options?, eventData?)\n\nStarts rendering one frame. Use this method with custom layers to redraw the map when the layer changes. Only one frame will be rendered, even If this method is called multiple times before visualizing the next frame.\n\nmap.triggerRepaint();\n\nReturns LngLat representing the geographic coordinates corresponding to the specified pixel coordinates. If the horizon is visible and the specified pixel is above the horizon, returns LngLat which corresponds to the point on the horizon closest to the point.\n\nOptions: point:PointLike pixel coordinates for unproject\n\nmap.on(\'click\', function(e) {\n\n// When the map is clicked, get the geographic\n\ncoordinate.\n\nvar coordinate = map.unproject(e.point);\n\n});\n\nUpdate an existing style image. This image can be displayed on the map like any other icon in a style sprite using an image ID with an icon-image, background-pattern, fill-pattern, or line -pattern).\n\nOptions: id:string image ID image:(HTMLImageElement | ImageBitmap | ImageData | {width: number, height: number, data: (Uint8ClampedArray | Uint8ClampedArray)} | StyleImageInterface) an image as HTMLImageElement, ImageData, ImageBitmap, or an object with width, height, and data properties in the same format as ImageData.\n\n// If an image with the ID \'cat\' already exists in the style\'s sprite, // replace that image with a new image, \'other-cat-icon.png\'. if (map.hasImage(\'cat\')) map.updateImage(\'cat\', \'./other-cat-icon.png\');\n\nMMR GL JS version as specified in package.json\n\nIncreases the map scale by 1.\n\nOptions: options:AnimationOptions options object eventData additional properties added to event objects that are called by this method.\n\n697\n\nzoomOut(options?, eventData?)\n\nzoomTo(zoom, options, eventData?)\n\n// zoom the map in one level with a custom animation duration map.zoomIn({duration: 1000});\n\nReduces the map scale by 1.\n\nOptions: options:AnimationOptions options object eventData additional properties added to event objects that are called by this method.\n\n// zoom the map out one level with a custom animation offset map.zoomOut({offset: [80, 60]});\n\nZooming the map to a given zoom level with an animated transition.\n\nOptions: zoom:number zoom level for the transition. options:AnimationOptions options object eventData additional properties added to event objects that are called by this method.\n\n// Zoom to the zoom level 5 without an animated transition map.zoomTo(5);\n\n// Zoom to the zoom level 8 with an animated transition map.zoomTo(8, {\n\nduration: 2000, offset: [100, 50]\n\n});\n\n698\n\nEvents\n\nName\n\nboxzoomcancel\n\nboxzoomend\n\nboxzoomstart\n\nDescription\n\nTriggered when the user cancels the ""box zoom"" interaction or when the bounding box does not meet the minimum size threshold. See BoxZoomHandler\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // the user cancels a ""box zoom"" interaction. map.on(\'boxzoomcancel\', function() {\n\nconsole.log(\'A boxzoomcancel event occurred.\');\n\n});\n\nTriggered when ""box zoom"" is finished. See BoxZoomHandler\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // just after a ""box zoom"" interaction ends. map.on(\'boxzoomend\', function() {\n\nconsole.log(\'A boxzoomend event occurred.\');\n\n});\n\nTriggered when «box zoom» is started. See BoxZoomHandler\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // just before a ""box zoom"" interaction starts. map.on(\'boxzoomstart\', function() {\n\nconsole.log(\'A boxzoomstart event occurred.\');\n\n});\n\n699\n\nclick\n\ncontextmenu\n\nTriggered when pressed.\n\nThis event is compatible with']","To interact with the map using touch gestures and trigger a repaint, you can use the TouchZoomRotateHandler. Additionally, you can call the triggerRepaint() method to start rendering one frame, which can be useful when working with custom layers to redraw the map after a layer change.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To interact with the map using touch gestures and trigger a repaint, you can utilize the 'touchmove' and 'touchstart' events in the map. 

1. **Touchmove Event**: This event is triggered when a touchmove event occurs on the map. You can initialize the map and set an event listener that fires when a touchmove event occurs within the map. Here is an example code snippet:
   ```javascript
   map.on('touchmove', function() {
       console.log('A touchmove event occurred.');
   });
   ```
   This code will log a message when a touchmove event is detected on the map.

2. **Touchstart Event**: This event is triggered when a touchstart event occurs on the map. Similar to the touchmove event, you can initialize the map and set an event listener for touchstart events. Here is an example code snippet:
   ```javascript
   map.on('touchstart', function() {
       console.log('A touchstart event occurred.');
   });
   ```
   This code will log a message when a touchstart event is detected on the map.

By using these touch events in your map interactions, you can trigger a repaint or update of the map based on touch gestures.","To interact with the map using touch gestures, you can utilize two handlers provided by the map library:

1. **TouchPitchHandler**: This handler allows users to pan the map using touch gestures.
2. **TouchZoomRotateHandler**: This handler enables users to zoom or rotate the map using touch gestures.

Additionally, to trigger a repaint of the map, you can use the `triggerRepaint()` method. This method is particularly useful when working with custom layers and you need to redraw the map when the layer changes. It ensures that only one frame is rendered, even if the method is called multiple times before visualizing the next frame.

Here is an example of how you can use these functionalities:

```javascript
// Initialize the map
var map = new mmrgl.Map({ /* map options */ });

// Set up touch gesture handlers
var touchPitchHandler = new mmrgl.TouchPitchHandler(map);
var touchZoomRotateHandler = new mmrgl.TouchZoomRotateHandler(map);

// Trigger a repaint of the map
map.triggerRepaint();
```

By incorporating the touch gesture handlers and triggering a repaint, you can enhance the user experience and update the map display as needed."
What are the mouse events triggered on a map in mmrgl when the cursor enters or leaves a specified layer?,"[' map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when an error occurs. map.on(\'error\', function() {\n\nconsole.log(\'A error event occurred.\');\n\n});\n\n703\n\nidle\n\nload\n\nTriggered after the last frame drawn before the map enters the ""idle"" state: ● ● ●\n\nno camera transitions occur all currently requested tiles have been loaded all fade/transition animations have been completed\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // just before the map enters an ""idle"" state. map.on(\'idle\', function() {\n\nconsole.log(\'A idle event occurred.\');\n\n});\n\nTriggered immediately after all the necessary resources were loaded and the map was visually rendered for the first time.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the map has finished loading. map.on(\'load\', function() {\n\nconsole.log(\'A load event occurred.\');\n\n});\n\n704\n\nmousedown\n\nmouseenter\n\nTriggered when you click inside the map.\n\nThis event is compatible with the optional layerId parameter. If layerId is included as the second argument to Map#on, the event listener will only trigger when the cursor is clicked inside the visible part of the specified layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener map.on(\'mousedown\', function() {\n\nconsole.log(\'A mousedown event has occurred.\');\n\n});\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener for a specific layer map.on(\'mousedown\', \'poi-label\', function() {\n\nconsole.log(\'A mousedown event has occurred on a\n\nvisible portion of the poi-label layer.\'); });\n\nTriggered when the cursor enters the visible part of the specified layer beyond that layer or beyond the map canvas.\n\nThis event can only be listened for when Map#on includes three arguments, where the second argument specifies the desired layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener map.on(\'mouseenter\', \'water\', function() {\n\nconsole.log(\'A mouseenter event occurred on a visible\n\nportion of the water layer.\'); });\n\n705\n\nmouseleave\n\nmousemove\n\nTriggered when the cursor leaves the visible part of the specified layer or leaves the map canvas.\n\nThis event can only be listened for when Map#on includes three arguments, where the second argument specifies the desired layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the pointing device leaves // a visible portion of the specified layer. map.on(\'mouseleave\', \'water\', function() {\n\nconsole.log(\'A mouseleave event occurred.\');\n\n});\n\nTriggered when the cursor moves while the cursor is inside the map. When moving the cursor around the map, the event will trigger every time the cursor changes its position on the map.\n\nThis event is compatible with the optional layerId parameter. If layerId is included as the second argument to Map#on, the event listener will only trigger when the cursor is inside the visible part of the specified layer.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener map.on(\'mousemove\', function() {\n\nconsole.log(\'A mousemove event has occurred.\');\n\n});\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener for a specific layer map.on(\'mousemove\', \'poi-label\', function() {\n\nconsole.log(\'A mousemove event has occurred on a\n\nvisible portion of the poi-label layer.\'); });\n\n706\n\nmouseout\n\nmouseover\n\nTriggered when the mouse cursor leaves the map canvas.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the pointing device leave\'s // the map\'s canvas. map.on(\'mouseout\', function() {\n\nconsole.log(\'A mouseout event occurred.\');\n\n});\n\nTriggered when the mouse cursor moves inside the map.']","The mouse events triggered on a map in mmrgl when the cursor enters or leaves a specified layer are 'mouseenter' and 'mouseleave'. The 'mouseenter' event is triggered when the cursor enters the visible part of the specified layer, while the 'mouseleave' event is triggered when the cursor leaves the visible part of the specified layer or leaves the map canvas.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"In mmrgl, when the cursor enters or leaves a specified layer on a map, the following mouse events are triggered:

1. **mouseenter**: This event is triggered when the cursor enters the visible part of the specified layer beyond that layer or beyond the map canvas. It can only be listened for when using Map#on with three arguments, where the second argument specifies the desired layer. An example code snippet for setting an event listener for this event is:
   ```javascript
   map.on('mouseenter', 'water', function() {
       console.log('A mouseenter event occurred on a visible portion of the water layer.');
   });
   ```

2. **mouseleave**: This event is triggered when the cursor leaves the visible part of the specified layer or leaves the map canvas. Similar to mouseenter, it can only be listened for with three arguments in Map#on. An example code snippet for setting an event listener for this event is:
   ```javascript
   map.on('mouseleave', 'water', function() {
       console.log('A mouseleave event occurred.');
   });
   ```

These events provide developers with the ability to track when the cursor enters or leaves specific layers on the map in mmrgl.","In mmrgl, when the cursor enters or leaves a specified layer on a map, the following mouse events are triggered:

1. **mouseenter**: This event is triggered when the cursor enters the visible part of the specified layer beyond that layer or beyond the map canvas. It can be listened for using `map.on('mouseenter', 'layerName', function() {...});`.

2. **mouseleave**: This event is triggered when the cursor leaves the visible part of the specified layer or leaves the map canvas. It can be listened for using `map.on('mouseleave', 'layerName', function() {...});`.

These events provide specific interactions related to the cursor entering or leaving a particular layer on the map in mmrgl."
What's the error structure of RuStoreException in the SDK and how are errors handled in SDK methods?,"['\nUSTRUCT(BlueprintType)\n\nstruct FURuStoreResponseWithCode\n\n{\n\nGENERATED_USTRUCT_BODY()\n\nFURuStoreResponseWithCode()\n\n{\n\ncode = 0;\n\nerrorMessage = """";\n\nerrorDescription = """";\n\n}\n\nUPROPERTY(BlueprintReadOnly)\n\nint code;\n\nUPROPERTY(BlueprintReadOnly)\n\nFString errorMessage;\n\nUPROPERTY(BlueprintReadOnly)\n\nFString errorDescription;\n\nUPROPERTY(BlueprintReadOnly)\n\nTArray<FURuStoreDigitalShopGeneralError> errors;\n\n};\n\ncode — response code.\n\nerrorMessage — error message.\n\nerrorDescription — error description.\n\nerrors — list of errors.\n\nError structure\n\n367\n\nUSTRUCT(BlueprintType)\n\nstruct FURuStoreDigitalShopGeneralError\n\n{\n\nGENERATED_USTRUCT_BODY()\n\nFURuStoreDigitalShopGeneralError()\n\n{\n\nname = """";\n\ncode = 0;\n\ndescription = """";\n\n}\n\nUPROPERTY(BlueprintReadOnly)\n\nFString name;\n\nUPROPERTY(BlueprintReadOnly)\n\nint code;\n\nUPROPERTY(BlueprintReadOnly)\n\nFString description;\n\n};\n\nname — error name. ● code — error code. ● description — error description.\n\nConsumption and cancellation scenario\n\nUncompleted payments must be processed by the AnyApp developer.\n\nThe purchase cancellation method should be used if:\n\n1. The method of getting the list of products returned the purchase status as follows:\n\nPurchaseState.CREATED; ○ PurchaseState.INVOICE_CREATED;\n\n2. 3.\n\nIf purchaseProduct returned PaymentResult.InvalidPurchase. If purchaseProduct returned PaymentResult.PurchaseResult that contains the following PaymentFinishCode:\n\nCLOSED_BY_USER — canceled by the user;\n\n368\n\nUNHANDLED_FORM_ERROR — unknown error; ○ PAYMENT_TIMEOUT — timeout payment error; ○ DECLINED_BY_SERVER — rejected by server; ○ RESULT_UNKNOWN — unknown payment status.\n\nThe confirmPurchase method should be used if:\n\n1. The getPurchases method returned the purchase status as follows:\n\nPurchaseState.PAID.\n\n2. The purchaseProduct method returned PaymentResult.PurchaseResult that contains\n\nthe following PaymentFinishCode:\n\nSUCCESSFUL_PAYMENT — successful payment.\n\nError handling\n\nAll possible errors are processed by onFailure handler of SDK methods.\n\nError structure\n\nUSTRUCT(BlueprintType)\n\nstruct RUSTORECORE_API FURuStoreRuStoreError\n\n{\n\nGENERATED_USTRUCT_BODY()\n\nFURuStoreRuStoreError()\n\n{\n\nname = """";\n\ndescription = """";\n\n}\n\nUPROPERTY(BlueprintReadOnly)\n\nFString name;\n\nUPROPERTY(BlueprintReadOnly)\n\nFString description;\n\n};\n\nname — error name.\n\ndescription — error description.\n\n369\n\nPossible errors:\n\nRuStoreNotInstalledException — user’s device doesn’t have RuStore installed. ● RuStoreOutdatedException — RuStore installed on a user\'s device doesn’t support push notifications.\n\nRuStoreUserUnauthorizedException — the user is not logged in to the RuStore. ● RuStoreFeatureUnavailableException — RuStore app is not allowed to run in the background.\n\nRuStoreException — RuStore basic error from which all the other errors are inherited.\n\nWhen calling the PurchaseProduct method, errors are handled automatically.\n\nIf the allowNativeErrorHandling == true parameter was passed during SDK initialization, it is\n\npassed to the resolveForBilling method apart from calling the corresponding onFailure\n\nhandler.\n\nError handling\n\npublic fun RuStoreException.resolveForBilling(context: Context)\n\nYou can change this behavior after initialization by setting the AllowNativeErrorHandling\n\nproperty:\n\nRestriction from native error handling\n\nRuStoreBillingClient::Instance()->AllowNativeErrorHandling =\n\nfalse;\n\n370\n\n371\n\nReact Native\n\nGeneral Information\n\nEmbed in your project How to initialize the library Payment functions availability\n\nGetting the List of Products Getting the List']","The error structure of RuStoreException in the SDK includes 'name' and 'description' fields. Errors in SDK methods are handled automatically, and if the allowNativeErrorHandling parameter is set to true during SDK initialization, it is passed to the resolveForBilling method along with calling the onFailure handler. Additionally, errors can be resolved for billing by calling the resolveForBilling method.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The error structure of RuStoreException in the SDK includes a constructor that allows passing a message as a parameter. This error serves as the basic error from which all other errors are inherited. 

In the SDK, errors are handled automatically when calling the PurchaseProduct method. If the allowNativeErrorHandling parameter is set to true during SDK initialization, errors are not only passed to the onFailure method but also returned to the resolveForBilling method in the native SDK. This allows the error to be displayed to the user. 

Additionally, after initialization, the behavior of error handling can be changed by setting the AllowNativeErrorHandling property to false. This property can be accessed through RuStoreBillingClient.Instance.AllowNativeErrorHandling.","The error structure of RuStoreException in the SDK is defined as follows:

```plaintext
USTRUCT(BlueprintType)
struct FURuStoreError
{
    GENERATED_USTRUCT_BODY()

    FURuStoreError()
    {
        name = """";
        description = """";
    }

    UPROPERTY(BlueprintReadOnly)
    FString name;

    UPROPERTY(BlueprintReadOnly)
    FString description;
}
```

This structure contains two fields:

- `name`: Represents the name of the error.
- `description`: Provides a description of the error.

In the SDK methods, errors are handled by passing them to the `onFailure` handler. When an error occurs, it is passed to the `onFailure` handler of the SDK methods. Additionally, if `allowNativeErrorHandling == true` was passed during the SDK initialization and an error occurs, the error is also passed to the `resolveForBilling` method of the native SDK to display an error dialog to the user.

Furthermore, the SDK provides a list of possible errors that can occur, including:

1. RuStoreNotInstalledException
2. RuStoreOutdatedException
3. RuStoreUserUnauthorizedException
4. RuStoreFeatureUnavailableException
5. RuStoreException

These errors are inherited from the base RuStoreException, and they are all handled automatically in the SDK methods."
"What steps should developers follow to promote their mobile apps in RuStore using VK Ads, and where can the ads appear?","["" event will be visible on your app card at the specified time period. Also, your event may be included in «Interesting», «Games», or «Apps» selection if picked by the RuStore team. View request To view a created request, follow these steps.\n\n\n\n\n\nFrom the navigation menu on the left, select Promotion > Events. The list of the created requests will be displayed. Select the request you need. The selected request page with the detailed information will be displayed.\n\nVK Ads on RuStore\n\nNow developers have the opportunity to promote their applications in RuStore with the help\n\nof advertising.\n\nHow to set up an advertising campaign via VK Ads\n\n140\n\n1. Open the VK Ads in your browser and log in. 2. Go to the Campaigns section. 3. Click Create Campaign.\n\n4. Click Mobile App. Select an advertised app from the list or link a new one through\n\nVK Ads.\n\nTo get started for the first time, you need to add an app and set up integration with the\n\ntracker. For more details, see How to add an application through VK Advertising below.\n\n141\n\n5. Set up an advertising campaign.\n\nVK Ads provides many tools and technologies so that you can customize your advertising\n\nas accurately as possible. See the Guide for more details on setting up an advertising\n\ncampaign.\n\nHow to add an app via VK Ads\n\n1. Open VK Ads.\n\n142\n\n2. Log in using one of available methods or create a new account. 3. Go to Mobile Applications and click Add Application.\n\n4. The add application form will open. Enter the link to the app in RuStore and click\n\nAdd.\n\n143\n\nTo find the link to your app, open the web version of the RuStore storefront.\n\nThe application status will change to Checking access.\n\n5. Start setting up integration with the tracker.\n\nRuStore also allows launching advertising campaigns on VK Ads via direct links without any\n\nthird-party tracking systems. To launch campaigns from RuStore, read the Guide.\n\nWhere your ads can appear\n\nAdvertising applications are available in Featuring. At that, ads are displayed to both\n\nauthorized and unauthorized users.\n\nFeatured Ads on RuStore:\n\nAn advertising banner appears when a user goes to the Featuring section. To go to the\n\napplication page, the user can click on the banner.\n\n144\n\nAds in Search results:\n\nThe ads will also appear at the top of the list in search results.\n\n145\n\nBy clicking on Install, the advertising application starts downloading in the same way as\n\nother applications from the search results.\n\n146\n\nTools\n\nGeneral information\n\nUse “Tools” in RuStore Console to connect developer tools to your apps.\n\nTools provide developers with additional options for app management, error detection, and integration with various services.\n\nOnly users with owner permissions can connect a tool.\n\nConnecting a tool\n\n1. Select the “Tools” tab. 2. Select an instrument of your interest from the side menu and click “Connect”. The system will display the following result message.\n\nIf an error occurs, contact our technical support.\n\nFrom the main console page the selected tool will be connected to all of your apps that have at least one created version in RuStore Console.\n\nYou can also connect a tool from the side menu of an app card. In this case the tool will be connected only to the selected app.\n\n147\n\nAfter connecting the tool you'll be able to see all connected apps in the tools section and switch directly to the app interface.\n\nOn connecting, an owner's account is created in a particular service in RuStore. To configure access for other employees of your organization after connecting a tool, switch to the service and configure access control in the tool interface.\n\nAfter connecting the tool you'll be able to see all connected apps in the tools section and switch directly to the app interface.\n\nOn connecting, an owner's account is created in a particular service in RuStore. To configure access for other employees of your organization after connecting a tool, switch to the service and configure access control in the tool interface.\n\nRuStore Remote Config\n\nGeneral information\n\nRuStore Remote Config is a tool for managing mobile app configuration. It allows to implement feature toggles (or feature switchers) and manage them from a convenient GUI.\n\nInfo You need a registered developer account to work with RuStore Remote Config.\n\nQuickstart\n\nSDK installation and app configuration; Creating conditions for enabling parameters; Description of the Remote Config parameters.\n\n148\n\nAdditional information\n\nUser permissions; How the service works.\n\nHow the""]","To promote their mobile apps in RuStore using VK Ads, developers should follow these steps: 1. Open VK Ads in the browser and log in. 2. Go to the Campaigns section and click Create Campaign. 3. Select Mobile App and choose the advertised app from the list or link a new one. 4. Set up the advertising campaign with customization options. Developers can also add an app via VK Ads by logging in, going to Mobile Applications, and clicking Add Application. They need to enter the link to the app in RuStore and click Add. The ads can appear in Featuring and Search results on RuStore.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To promote their mobile apps in RuStore using VK Ads, developers should follow these steps:

1. Open VK Ads in your browser and log in.
2. Go to the Campaigns section.
3. Click Create Campaign.
4. Click Mobile App.
5. Select an advertised app from the list or link a new one through VK Ads.
6. Start setting up integration with the tracker.

Additionally, developers can launch advertising campaigns on VK Ads via direct links without any third-party tracking systems. The ads can appear in the Featuring section of RuStore. Featured Ads on RuStore are displayed to both authorized and unauthorized users. An advertising banner will appear when a user goes to the Featuring section, and by clicking on the banner, the user can go to the application page.

In summary, developers can promote their mobile apps in RuStore using VK Ads by setting up integration with the tracker and launching advertising campaigns that can appear in the Featuring section of RuStore.","To promote their mobile apps in RuStore using VK Ads, developers should follow these steps:

1. Open VK Ads and log in.
2. Go to the Campaigns section and click Create Campaign.
3. Select Mobile App and choose the app to advertise or link a new one through VK Ads.
4. Set up the advertising campaign using the tools provided by VK Ads.

Ads for the promoted apps can appear in the following locations on RuStore:
- Featuring section: An advertising banner is displayed when users visit this section, and they can click on the banner to go to the app page.
- Search results: Ads will appear at the top of the list in search results.
- By clicking on Install, the advertising application starts downloading like other apps from search results.

These are the steps developers should follow to promote their mobile apps in RuStore using VK Ads and where the ads can appear."
How to set global settings for Maps Mobile SDK with MapGlobalConfig and the best way to initialize them?,"['""\n\n}\n\n} } }\n\nYou should also specify the dependency in the gradle file, as shown in the example.\n\nDependency injection\n\nimplementation(\'ru.rustore.geo:mapkit:x.x.x\') where x.x.x — SDK version.\n\nWe recommend using the latest SDK version. Release versions of SDK are numbered 1.0.x\n\nThe latest SDK version is available at: https://github.com/geors?tab=packages&repo_name=maps-sdk-android\n\n872\n\nHow to use Maps Mobile SDK\n\nIt is required to initialize the card global settings before using any other SDK component, the best option is in the Application class successor. The global settings object is:\n\nclass MapViewConfig(\n\nval apiKey: String, // unique key to grant access to SDK\n\n)\n\ninstall the object:\n\nMapGlobalConfig.setMapGlobalConfig(\n\nMapViewConfig(\n\napiKey = apiKey\n\n)\n\n)\n\nTo start working with SDK, a number of classes are provided that implement View in one form or another:\n\ndata class MapStartOptions(\n\nval center: LatLon, // initial map location point (only for\n\nlat, lon)\n\nval zoomLevel: Float, // initial zoom level (zoomLevel)\n\nval style: MapStyle, // map style, you can select the\n\ncorresponding enum or use your own\n\nval compassLocationMode: CompassLocationMode, // compass\n\nsetting, can be selected from the corresponding enum\n\nval logoConfig: LogoConfig // logo configuration\n\n)\n\nYou need to set the start settings as shown in the example.\n\nMapGlobalConfig.setMapStartOptions(MapStartOptions(...))\n\nLogoConfig example\n\n873\n\ndata class LogoConfig(\n\nval logoAlignment: Alignment, // Alignment: BottomRight,\n\nBottomLeft, TopRight, TopLeft\n\nval logoAdditionalPaddings: AdditionalPaddings\n\n)\n\nTo work with the SDK, a number of classes are provided that implement View in one form or another:\n\nMapView is the main view in the SDK that displays the map; - - CurrentLocationView is a button to focus the map on the current user position and follow his position;\n\nCompassView is a component that displays the direction of a physical device relative to\n\nthe north.\n\nTo display these controls, you must place them in the xml file.\n\n<FrameLayout\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.rustore.geo.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n</FrameLayout>\n\nMap example\n\n<FrameLayout\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.mail.maps.sdk.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n874\n\n</FrameLayout>\n\nThis may be enough to work with the map if other elements are not required.\n\nConrols example\n\n<FrameLayout\n\nxmlns:custom=""http://schemas.android.com/apk/res-auto""\n\nandroid:id=""@+id/mainLayout""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent""\n\n...>\n\n<ru.rustore.geo.views.MapView\n\nandroid:id=""@+id/mapView""\n\nandroid:layout_width=""match_parent""\n\nandroid:layout_height=""match_parent"" />\n\n<ru.rustore.geo.views.ZoomView\n\nandroid:id=""@+id/zoomView""\n\nandroid:layout_width=""wrap_content""\n\nandroid:layout_height=""wrap_content""\n\n...\n\ncustom:mapView=""@+id/mapView"" />\n\n<ru.rustore.geo.views.CompassView\n\nandroid:layout_width=""wrap_content""']","To set global settings for Maps Mobile SDK with MapGlobalConfig, you need to create a MapViewConfig object with the apiKey parameter and then initialize it using MapGlobalConfig.setMapGlobalConfig(). The best way to initialize these global settings is in the Application class successor.",reasoning,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To set global settings for Maps Mobile SDK using MapGlobalConfig, you need to initialize the card global settings before using any other SDK component. The best way to initialize them is in the Application class successor. 

You can set the global settings object using the following steps:
1. Create a MapViewConfig object with your API key.
2. Install the object using MapGlobalConfig.setMapGlobalConfig(MapViewConfig(apiKey = apiKey)).

By following these steps, you can successfully set the global settings for Maps Mobile SDK using MapGlobalConfig and initialize them in the Application class successor.","To set global settings for Maps Mobile SDK using MapGlobalConfig, you need to follow these steps:

1. Create a MapViewConfig object that contains the necessary information, such as the API key to access the SDK.
   
   Example:
   ```
   val mapViewConfig = MapViewConfig(
       apiKey = ""YOUR_API_KEY_HERE""
   )
   ```

2. Initialize the MapGlobalConfig with the created MapViewConfig object.

   Example:
   ```
   MapGlobalConfig.setMapGlobalConfig(mapViewConfig)
   ```

The best way to initialize these global settings is in the Application class successor. By initializing the global settings in the Application class, you ensure that they are set up before any other SDK component is used, providing a centralized and efficient way to manage the SDK configuration.

Here's a summary of the steps to set global settings for Maps Mobile SDK using MapGlobalConfig:

1. Create a MapViewConfig object with the required information.
2. Initialize the MapGlobalConfig with the MapViewConfig object.
3. Consider initializing these settings in the Application class for efficient management.

If you have any more questions or need further assistance, feel free to ask!"
What does map.getMaxBounds() return and why is map.getLight() used?,"["" layer property name to be obtained.\n\nReturns the light object value .\n\nReturns the maximum geographic boundaries the map is bound to, or null if they are not set.\n\nvar maxBounds = map.getMaxBounds();\n\nReturns the maximum allowable tilt of the map.\n\nReturns the maximum acceptable zoom level for the map.\n\nvar maxZoom = map.getMaxZoom();\n\nReturns the minimum allowable map step.\n\nReturns the minimum acceptable zoom level for the map.\n\nvar minZoom = map.getMinZoom();\n\nReturns the current padding applied around the map viewport.\n\nname:string paint name to be obtained.\n\nReturns the paint property value on the specified style layer.\n\nOptions: layerId:string layer ID from which the paint property will be derived. name:string paint property name to be obtained.\n\nReturns the current tilt of the map.\n\n672\n\ngetRenderWorldCopi es()\n\ngetSource(id)\n\ngetStyle()\n\ngetTerrain()\n\ngetZoom()\n\nhasControl(control)\n\nReturns the state of renderWorldCopies. If this is true, then multiple copies of the world will be rendered side by side beyond -180 and +180 degrees of longitude. If set to false:\n\nwhen the map is zoomed so that no image of the world fills the entire map container, there will be empty space beyond +180 and -180 degrees of longitude.\n\nfeatures that intersect +180 and -180 degrees of longitude will be divided in two (one on the right edge of the map and one on the left) at each zoom level.\n\nvar worldCopiesRendered = map.getRenderWorldCopies();\n\nReturns the source with the specified map-style ID.\n\nThis method is often used to update a source with instance elements for the appropriate source type defined in sources. For example, to set the data for a GeoJSON source, or update the URL and coordinates of an image source.\n\nOptions: id:string source ID to be obtained.\n\nvar sourceObject = map.getSource('points');\n\nReturns the map style object, a JSON object that can be used to recreate the map style.\n\nmap.on('load', function() {\n\nvar styleJson = map.getStyle();\n\n});\n\nReturns the terrain specification, or null if terrain is not defined on the map.\n\nReturns the current map zoom level.\n\nmap.getZoom();\n\nVerifies whether there is a control on the map.\n\nOptions: control:IControl IControl for navigation control\n\n// Define a new navigation control. var navigation = new mmrgl.NavigationControl(); // Add zoom and rotation controls to the map. map.addControl(navigation); // Check that the navigation control exists on the map. const added = map.hasControl(navigation);\n\n673\n\nhasImage(id)\n\nisMoving()\n\nisRotating()\n\nisSourceLoaded(id)\n\nisStyleLoaded()\n\nisZooming()\n\n// added === true\n\nChecks if an image with a specific ID exists in the style. Validates both the images in the original style sprite and any images added using the Map#addImage method.\n\nOptions: id:string image ID.\n\n// Check if an image with the ID 'cat' exists in // the style's sprite. var catIconExists = map.hasImage('cat');\n\nReturns true if the map is moved, scaled, rotated, or tilted via a camera animation or user gesture.\n\nvar isMoving = map.isMoving();\n\nReturns true if the map is rotating via a camera animation or user gesture. map.isRotating();\n\nReturns a Boolean value indicating whether the source has been loaded. Returns true if the source with the given map style ID has no network requests, otherwise returns false.\n\nOptions: id:string source ID to be verified\n\nvar sourceLoaded = map.isSourceLoaded('bathymetry-data');\n\nReturns a Boolean value indicating whether the map style is fully loaded.\n\nvar styleLoadStatus = map.isStyleLoaded();\n\nReturns true if the map is zoomed via a camera animation or user gesture.\n\nvar isZooming = map.isZooming();\n\n674\n\njumpTo(options, eventData?)\n\nkeyboard\n\nlistImages()\n\nloaded()\n\nloadImage(url, callback)\n\nChanges any combination of center, zoom, bearing and pitch without an animated transition. The map will retain its current values for any details not specified in the options.\n\nOptions: options""]","Returns the maximum geographic boundaries the map is bound to, or null if they are not set.",multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The function map.getMaxBounds() returns the maximum geographic boundaries that the map is bound to. If these boundaries are not set, the function will return null. This function is useful for limiting pan and zoom operations within specific geographical limits on the map.

The function map.getLight() is used to return the light object value. This function is helpful for accessing and manipulating the lighting properties of the map, which must match the style specification. It allows developers to customize the lighting properties of the map to enhance the visual representation of the map features.","The `map.getMaxBounds()` function returns the maximum geographic boundaries that the map is bound to. If these boundaries are not set, the function will return null. This function is useful for determining the limits of the map's viewable area.

On the other hand, the `map.getLight()` function is used to retrieve the light object value. This function allows developers to access and manipulate the lighting settings of the map, such as the position and intensity of the light source. It can be used to customize the visual appearance of the map by adjusting the lighting conditions.

In summary, `map.getMaxBounds()` helps in understanding the map's boundaries, while `map.getLight()` is used for controlling the lighting effects on the map."
What is the unique purchase identifier and its location in the purchase info?,"[' getPurchaseTime() — purchase time (in RFC 3339 format); ● getOrderId() — unique payment identifier generated by the application (uuid); ● getAmountLabel() — formatted purchase price, including the currency symbol in [language];\n\ngetAmount() — price in minor units of currency; ● getCurrency() — ISO 4217 currency code; ● getQuantity() — number of products; ● getPurchaseState() — purchase status:\n\n268\n\npossible values of the purchase condition:\n\n■ CREATED — created; ■ INVOICE_CREATED — created, waiting for payment; ■ CONFIRMED — confirmed; ■ PAID — paid for; ■ CANCELLED — purchase canceled; ■ CONSUMED — purchase consumption is confirmed; ■ CLOSED — subscription is canceled.\n\ngetDeveloperPayload() — line specified by the developer that contains additional\n\ninformation about the order;\n\ngetSubscriptionToken() — token for validating a purchase on the server.\n\nThe purchaseState model:\n\nA status-based subscription purchase model (SUBSCRIPTIONS):\n\n269\n\nA status-based non-consumables subscription (NON-CONSUMABLES):\n\nA status-based consumables subscription (CONSUMABLES):\n\n270\n\nHow to get purchase info\n\nUse the getPurchaseInfo method to get information about purchases:\n\nPurchasesUseCase purchasesUseCase = billingClient.getPurchases();\n\npurchasesUseCase.getPurchaseInfo(""purchaseId"").addOnCompleteListene\n\nr(new OnCompleteListener<PurchaseInfoResponse>() {\n\n@Override\n\npublic void onFailure(@NonNull Throwable throwable) {\n\n// Process error\n\n}\n\n@Override\n\npublic void onSuccess(PurchaseInfoResponse result) {\n\n// Process success\n\n}\n\n});\n\nProduct Structure:\n\ninterface Purchase {\n\n@Nullable\n\npublic String getPurchaseId();\n\npublic String getProductId();\n\n@Nullable\n\npublic ProductType getProductType();\n\n@Nullable\n\npublic String getInvoiceId();\n\n@Nullable\n\npublic String getDescription();\n\n@Nullable\n\npublic String getLanguage();\n\n@Nullable\n\npublic Date getPurchaseTime();\n\n271\n\n}\n\n@Nullable\n\npublic String getOrderId();\n\n@Nullable\n\npublic String getAmountLabel();\n\n@Nullable\n\npublic Integer getAmount();\n\n@Nullable\n\npublic String getCurrency();\n\n@Nullable\n\npublic Integer getQuantity();\n\n@Nullable\n\npublic PurchaseState getPurchaseState();\n\n@Nullable\n\npublic String getDeveloperPayload();\n\n@Nullable\n\npublic String getSubscriptionToken();\n\ngetPurchaseId() — purchase ID; ● getProductId() — product identifier; ● getProductType() — product type; ● getInvoiceId() — invoice ID; ● getDescription() — purchase description; ● getLanguage() — language specified with the BCP 47 encoding; ● getPurchaseTime() — purchase time (in RFC 3339 format); ● getOrderId() — unique payment identifier generated by the application (uuid); ● getAmountLabel() — formatted purchase price, including the currency symbol in [language];\n\ngetAmount() — price in minor units of currency; ● getCurrency() — ISO 4217 currency code; ● getQuantity() — number of products; ● getPurchaseState() — purchase status:\n\npossible values of the purchase condition:\n\n■ CREATED — created;\n\n272\n\n■ INVOICE_CREATED — created, waiting for payment; ■ CONFIRMED — confirmed; ■ PAID — paid for; ■ CANCELLED — purchase canceled; ■ CONSUMED — purchase consumption is confirmed; ■ CLOSED — subscription is canceled.\n\ngetDeveloperPayload() — line specified by the developer that contains additional\n\ninformation about the order;\n\ngetDeveloperPayload() — token for server purchase validation.\n\nThe purchaseState model:\n\nA status-based subscription purchase model (SUBSCRIPTIONS):\n\n273\n\nA status-based non-consumables subscription (NON-CONSUMABLES):\n\nA status-based consumables subscription (CONSUMABLES):\n\n274\n\nHow to handle purchases\n\nUse the purchaseProduct method to call a product purchase:\n\nPurchasesUseCase purchasesUseCase = billingClient.getPurchases();\n\npurchasesUseCase.purchaseProduct(""productId"").addOnCompleteListener\n\n(new OnCompleteListener<PaymentResult>() {\n\n@']","The unique purchase identifier is the purchase ID, and it is located in the getPurchaseId() method of the Purchase interface.",multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The unique purchase identifier in the purchase info is referred to as the ""purchaseId."" It is used as a parameter in the GetPurchaseInfo method to retrieve specific purchase information. The purchaseId is a unique identifier associated with each purchase and is essential for retrieving details such as product ID, product type, purchase description, purchase time, payment ID, purchase price, currency code, quantity, purchase state, developer payload, and subscription token. The purchaseId plays a crucial role in identifying and accessing detailed information about a specific purchase within the Rustore system.","The unique purchase identifier is called ""purchaseId."" It is a part of the Purchase interface in the purchase info. You can access the unique purchase identifier by calling the method getPurchaseId() on the Purchase object. This identifier helps uniquely identify each purchase made by the user."
How to set up push notifications with Firebase and Huawei Mobile Services in the project?,"[' hms\n\nmaven {url = uri(""https://developer.huawei.com/repo/"")}\n\n}\n\n498\n\n}\n\n499\n\nGoogle Play\n\nSetting up the app\n\nTo publish an app on Google Play, you only need to add dependencies which are required to send push notifications through FCM and RuStore. To get started with FCM, set up a project in Firebase.\n\n1. Create a new project in the Firebase Console. 2. 3. 4. Go to Your apps and download google-services.json. 5. Once downloaded, move google-services.json to app/google-services.json.\n\nIn the Firebase Console, select the project you plan to enable push notifications for. In the left menu, next to the project name, click the gear icon and go to Project Settings.\n\nImporting to your project\n\nTo publish your app on Google Play Store, you are required to use universalfcm, universalrustore, and universalpush packages only.\n\nConnect the repository in settings.gradle at the root level:\n\ndependencyResolutionManagement {\n\nrepositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories {\n\ngoogle() mavenCentral() // required for rustore maven {\n\nurl =\n\nuri(""https://artifactory-external.vkpartner.ru/artifactory/maven"")\n\n}\n\n}\n\n}\n\nDependency injection\n\nAdd the following code to your build.gradle to inject the dependency at the app level:\n\ndependencies {\n\nimplementation(\'ru.rustore.sdk:universalpush:0.1.1\') implementation(\'ru.rustore.sdk:universalrustore:0.1.0\') implementation(\'ru.rustore.sdk:universalfcm:0.1.0\')\n\n}\n\nAdd the following rule when using the SDK in your app along with ProGuard:\n\n500\n\nkeep public class com.vk.push.** extends android.os.Parcelable\n\nFollow the steps below to work with FCM: ● add to build.gradle at the app level\n\nplugins {\n\n// ...\n\n// required for fcm id \'com.google.gms.google-services\'\n\n}\n\nadd to build.gradle at the root level\n\ndependencies {\n\n// required for fcm classpath \'com.google.gms:google-services:4.3.15\'\n\n}\n\n501\n\nHuawei Mobile Services\n\nSetting up the app\n\nTo publish an app on AppGallery, you only need to add dependencies which are required to send push notifications through HMS and RuStore. To get started with HMS, set up a project in developer.huawei.com.\n\n1. Create a new project in developer.huawei.com. 2. 3. Go to Project Settings - Main. 4. Then go to App data and download agconnect-services.json. 5. Once downloaded, move agconnect-services.json to app/agconnect-services.json.\n\nIn AppGallery Connect, select the project you plan to enable push notifications for.\n\nImporting to your project\n\nTo publish your app on AppGallery, you are required to use universalfcm, universalrustore, and universalpush packages only.\n\nConnect the repository in settings.gradle:\n\ndependencyResolutionManagement {\n\nrepositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n\nrepositories {\n\ngoogle()\n\nmavenCentral()\n\nmaven {url = uri(""https://developer.huawei.com/repo/"")}\n\nmaven {\n\nurl =\n\nuri(""https://artifactory-external.vkpartner.ru/artifactory/maven"")\n\n}\n\n}\n\n}\n\nDependency injection\n\nAdd the following code to your build.gradle to inject the dependency at the app level:\n\ndependencies {\n\nimplementation(\'ru.rustore.sdk:universalpush:0.1.1\') implementation(\'ru.rustore.sdk:universalrustore:0.1.0\') implementation(\'ru.rustore.sdk:universalhms:0.1.0\')\n\n}\n\nAdd the following rule when using the SDK in your app along with ProGuard:\n\n502\n\nkeep public class com.vk.push.** extends android.os.Parcelable\n\nFollow the steps']","To set up push notifications with Firebase, create a new project in the Firebase Console, download google-services.json, and import it to your project. For Huawei Mobile Services, create a new project in developer.huawei.com, download agconnect-services.json, and import it to your project. Connect the required repositories and dependencies for both services, and inject the necessary dependencies at the app level.",multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To set up push notifications with Firebase and Huawei Mobile Services in your project, you need to follow these steps:

1. Create a new project on developer.huawei.com.
2. In AppGallery Connect, select the project you plan to enable push notifications for.
3. Go to Project Settings - Main.
4. Then go to App data and download agconnect-services.json.
5. Once downloaded, move agconnect-services.json to app/agconnect-services.json.

To import the necessary dependencies for push notifications, you are required to use universalfcm, universalrustore, and universalpush packages only. Connect the repository in settings.gradle as shown in the documentation.

Next, add the following code to your build.gradle to inject the dependencies at the app level:
```
dependencies { 
    implementation('ru.rustore.sdk:universalpush:0.1.1') 
    implementation('ru.rustore.sdk:universalrustore:0.1.0') 
    implementation('ru.rustore.sdk:universalhms:0.1.0') 
}
```

By following these steps and adding the necessary dependencies, you can set up push notifications with Firebase and Huawei Mobile Services in your project.","To set up push notifications with Firebase and Huawei Mobile Services in your project, you need to follow these steps:

1. **Firebase Setup:**
   - Create a new project in the Firebase Console.
   - Select the project you plan to enable push notifications for.
   - In the left menu, next to the project name, click the gear icon and go to Project Settings.
   - Go to Your apps and download google-services.json.
   - Move the downloaded google-services.json file to app/google-services.json in your project.

2. **Huawei Mobile Services (HMS) Setup:**
   - Create a new project in developer.huawei.com.
   - In AppGallery Connect, select the project you plan to enable push notifications for.
   - Go to Project Settings - Main.
   - Then go to App data and download agconnect-services.json.
   - Move the downloaded agconnect-services.json file to app/agconnect-services.json in your project.

3. **Dependency Injection:**
   - Add the following code to your build.gradle at the app level:
     ```
     plugins {
         id 'com.google.gms.google-services' // required for FCM
         id 'com.huawei.agconnect' // required for HMS
     }
     ```

4. **Add Dependencies:**
   - In your build.gradle at the root level, add the following dependencies:
     ```
     dependencies {
         classpath 'com.google.gms:google-services:4.3.15' // for FCM
         classpath 'com.huawei.agconnect:agcp:1.6.0.300' // for HMS
         classpath 'com.android.tools.build:gradle:7.4.0'
     }
     ```

5. **Connect Repositories:**
   - In your settings.gradle at the root level, connect the necessary repositories for Firebase and HMS:
     ```
     pluginManagement {
         repositories {
             google()
             mavenCentral()
             gradlePluginPortal()
             maven {url = uri(""https://developer.huawei.com/repo/"")} // for HMS
         }
     }
     ```

By following these steps, you can set up push notifications with Firebase and Huawei Mobile Services in your project."
What is the role of RuStoreUniversalPushManager in MyMessagePushService and its connection to RuStorePushClient for push notifications and message processing?,"['.universalpush.hms.messaging.toNotificationPayload\n\nclass MyMessagePushService: HmsMessageService() {\n\noverride fun onMessageReceived(msg: RemoteMessage?) {\n\nsuper.onMessageReceived(msg)\n\nRuStoreUniversalPushManager.processMessage(msg.toNotificationPayloa d())\n\n}\n\noverride fun onNewToken(token: String?) {\n\nsuper.onNewToken(token)\n\nRuStoreUniversalPushManager.processToken(token)\n\n}\n\n}\n\nSDK Release Notes\n\nSDK version 1.0.0\n\nAdded deduplication of push notifications ● Added callbacks for:\n\nHandling notifications - Handling onDeletedMessages events - Handling onNewToken events\n\n512\n\nHandling push provider errors\n\n513\n\nApp Feedback and Rating SDK\n\nAndroid (Kotlin/Java)\n\nGeneral\n\nImporting SDK to your project\n\nCreating RuStoreReviewManager\n\nGetting ReviewInfo object\n\nStarting app rating\n\nPossible errors\n\nRuStore Change History Feedback and Rating SDK\n\n277\n\n279\n\n280\n\n281\n\n282\n\n283\n\n286\n\n514\n\nGeneral\n\nRuStore In-app Review SDK prompts the user to rate your app and leave feedback on the RuStore without exiting the app.\n\nRating and feedback user scenarios may be run at any time throughout the user’s path in your app. The user can rate your app from 1 to 5 and leave feedback. Feedback is optional.\n\nImplementation example\n\nSee the example app to learn how to integrate rating and feedback SDK correctly.\n\nUse case example\n\nConditions for correct operation of SDK\n\nFor rating and feedback SDK to operate correctly, the following conditions need to be met:\n\n1. Android 6.0 or later. 2. The RuStore app is installed on the user\'s device. 3. The current RuStoreApp version is installed on the user\'s device. 4. The user has logged in to the RuStore. 5. The app should be already installed on RuStore.\n\nWhen to ask to rate and leave feedback\n\nUse the tips below to decide when to ask the user to rate and leave feedback:\n\nStart the process once the user has been using your app for long enough. ● Avoid starting it too often as this will impair your app’s user experience and limit the use or SDK ratings.\n\nAvoid using calls to action like “Rate App” button as the user could have already reached\n\nthe process starting limit.\n\n515\n\nYour app should not ask the user any questions before the start or while the process is running, including their opinion (“Do you like the app?”) or predictive questions (“Would you give this app 5 stars?”).\n\nDesign tips\n\nUse the tips below to decide how to integrate the process:\n\nDisplay the process as is, without any intervention or modification of existing design,\n\nincluding size, opacity, shape and other properties.\n\nAdd nothing on top or on sides of the process. ● The process should open on top of all layers. Don’t close the process after starting. The process will close by itself after an express action by the user.\n\n516\n\nImporting SDK to your project\n\nConnect the repository:\n\nrepositories { maven {\n\nurl =\n\nuri(""https://artifactory-external.vkpartner.ru/artifactory/maven"")\n\n}\n\n}\n\nDependency injection\n\nAdd the following code to your configuration file to inject the dependency:\n\ndependencies {\n\nimplementation(""ru.rustore.sdk:pushclient:2.0.0"")\n\n}\n\n517\n\nCreating RuStoreReviewManager\n\nTo manage the rating process, you need to create RuStoreReviewManager using RuStoreReviewManagerFactory:\n\nval manager = RuStoreReviewManagerFactory.create(context)\n\n518\n\nGetting ReviewInfo object\n\nCall requestReviewFlow() in advance before calling launchReviewFlow(reviewInfo) to prepare necessary information to display.\n\nReviewInfo has a lifetime — about five minutes.\n\nmanager.requestReviewFlow().addOnCompleteListener(object :\n\nOnCompleteListener<ReviewInfo> {\n\noverride fun onFailure(throwable: Throwable) {\n\n// Handle error\n\n}\n\noverride fun onSuccess(result: ReviewInfo) {\n\n// Save reviewInfo\n\n}\n\n})\n\nIf onSuccess response is received, save ReviewInfo locally to call launchReviewFlow(reviewInfo) later.\n\n']",The role of RuStoreUniversalPushManager in MyMessagePushService is to process push notifications and messages received by the HmsMessageService. It connects to RuStorePushClient for handling push notifications and message processing.,multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"In the provided documents, there is a mention of a class called `MyFirebaseMessagingService`, which extends `FirebaseMessagingService`. Within this class, there is a method `onMessageReceived(message: RemoteMessage)` that processes incoming messages. In this method, there is a call to `RuStoreUniversalPushManager.processMessage(message.toNotificationPayload())`.

Based on this information, it can be inferred that `RuStoreUniversalPushManager` is responsible for processing incoming push notifications in the `MyFirebaseMessagingService` class. It seems to handle the conversion of the incoming message to a notification payload that can be further processed by the RuStorePushClient or other relevant components for message handling.

The connection between `RuStoreUniversalPushManager` and `RuStorePushClient` is not explicitly mentioned in the provided documents. However, it can be assumed that `RuStorePushClient` is a part of the RuStorePushNotifications SDK mentioned in the documentation, and it likely plays a role in handling push notifications within the RuStore app.

Therefore, `RuStoreUniversalPushManager` seems to be responsible for processing incoming push notifications in the `MyFirebaseMessagingService` class, and `RuStorePushClient` is likely involved in the overall handling of push notifications within the RuStore app, although the specific connection between the two components is not detailed in the documents.","In the provided documentation, there is no specific mention of a ""RuStoreUniversalPushManager"" or ""MyMessagePushService."" However, based on the information available, I can provide a general understanding of how RuStorePushClient is connected to push notifications and message processing.

1. **RuStorePushClient**:
   - RuStorePushClient is a component that facilitates push notifications in the RuStore SDK.
   - It provides methods for tasks such as checking push notification availability, obtaining push tokens, deleting push tokens, subscribing to topics, and handling events related to push notifications.
   - The client interacts with different push notification providers like Firebase (FCM), Huawei Mobile Services (HMS), and RuStore to manage push notifications.

2. **Message Processing**:
   - RuStorePushClient handles message processing related to push notifications.
   - It includes functionalities for receiving notifications, managing token updates, subscribing and unsubscribing from topics, and handling events like deleted messages and new tokens.
   - The client also provides callbacks for handling notifications, errors, and other push-related events.

3. **Connection to MyMessagePushService** (Hypothetical):
   - If ""MyMessagePushService"" is a custom service or component in your application, it could potentially interact with RuStorePushClient for message processing and push notification management.
   - MyMessagePushService may utilize RuStorePushClient's methods and callbacks to handle incoming push notifications, process messages, update tokens, and subscribe to topics.
   - The service could integrate with RuStorePushClient's event listeners to respond to events like deleted messages, new tokens, and notification reception.

In summary, while the specific details of RuStoreUniversalPushManager and MyMessagePushService are not mentioned in the documentation, RuStorePushClient plays a crucial role in managing push notifications, message processing, and event handling within the RuStore SDK ecosystem. If you have further questions or need more specific information, feel free to ask!"
What happens on the map with touchmove event? What event occurs when WebGL context is restored?,"["" when there is no icon or template required by the style. A missing image can be added using Map#addImage to prevent the image from being skipped. This event can be used to dynamically generate icons and templates.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // an icon or pattern is missing. map.on('styleimagemissing', function() {\n\nconsole.log('A styleimagemissing event occurred.');\n\n});\n\nTriggered when a touchcancel event occurs on the map.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when a touchcancel event occurs within the map. map.on('touchcancel', function() {\n\nconsole.log('A touchcancel event occurred.');\n\n});\n\nTriggered when a touchend event occurs on the map.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when a touchstart event occurs within the map. map.on('touchstart', function() {\n\nconsole.log('A touchstart event occurred.');\n\n});\n\n714\n\ntouchmove\n\ntouchstart\n\nwebglcontextlost\n\nTriggered when a touchmove event occurs on the map.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when a touchmove event occurs within the map. map.on('touchmove', function() {\n\nconsole.log('A touchmove event occurred.');\n\n});\n\nTriggered when a touchstart event occurs on the map.\n\nParameters: data:MapMouseEvent\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when a touchstart event occurs within the map. map.on('touchstart', function() {\n\nconsole.log('A touchstart event occurred.');\n\n});\n\nTriggered when the WebGL context is lost.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the WebGL context is lost. map.on('webglcontextlost', function() {\n\nconsole.log('A webglcontextlost event occurred.');\n\n});\n\n715\n\nwebglcontextrest ored\n\nwheel\n\nzoom\n\nTriggered when the WebGL context is restored.\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when the WebGL context is restored. map.on('webglcontextrestored', function() {\n\nconsole.log('A webglcontextrestored event occurred.');\n\n});\n\nTriggered when the map is scrolled by the wheel\n\nParameters: data:MapMouseEvent\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // when a wheel event occurs within the map. map.on('wheel', function() {\n\nconsole.log('A wheel event occurred.');\n\n});\n\nTriggered repeatedly during an animated transition from one zoom level to another as a result of user interaction or methods such as Map#flyTo\n\nParameters: data:(MapMouseEvent | MapTouchEvent)\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // repeatedly during a zoom transition. map.on('zoom', function() {\n\nconsole.log('A zoom event occurred.');\n\n});\n\n716\n\nzoomend\n\nzoomstart\n\nTriggered immediately after the map has completed transitioning from one zoom level to another, either as a result of user interaction or methods such as Map#flyTo.\n\nParameters: data:(MapMouseEvent | MapTouchEvent)\n\n// Initialize the map var map = new mmrgl.Map({ // map options }); // Set an event listener that fires // just after a zoom transition finishes. map.on('zoomend', function() {\n\nconsole.log('A zoomend event occurred.');\n\n});\n\nTriggered just before the map starts transitioning from one zoom level to another, either as a result of user interaction or methods such as Map#flyTo.\n\nParameters: data:(MapMouseEvent | MapTouchEvent)\n\n// Initialize the map var map = new mmrgl.Map({ //""]","A touchmove event occurs on the map when the user moves their touch input across the map. When the WebGL context is restored, a webglcontextrestored event occurs.",multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"When a touchmove event occurs on the map, a specific action is triggered. In this case, the touchmove event is associated with the action of logging a message to the console. The code snippet provided in the documentation shows that when a touchmove event occurs within the map, the message ""A touchmove event occurred."" is logged to the console.

On the other hand, when the WebGL context is restored, the webglcontextrestored event is triggered. In this event, a message is logged to the console indicating that the webglcontextrestored event has occurred. This event is associated with the restoration of the WebGL context within the map.

Therefore, on the map, the touchmove event triggers the logging of a message to the console, while the webglcontextrestored event occurs when the WebGL context is restored.","When a touchmove event occurs on the map, the ""touchmove"" event is triggered. This event is specifically related to touch interactions on the map, indicating that a touch input has moved across the map.

Regarding the event that occurs when the WebGL context is restored, this information is not provided in the document. Therefore, I don't have details on the specific event triggered when the WebGL context is restored."
How to gather and analyze native crashes using Tracer with enabled and configured crash reporting?,"[' up-to-date information.\n\nNow the tracer configuration is done at the current tracer start-up instead of the next tracer start-up.\n\nTracer Modules\n\nCrash and ANR\n\nConnecting dependencies to your project In your <project>/<app-module>/build.gradle.\n\ndependencies {\n\nimplementation ""ru.ok.tracer:tracer-crash-report:0.2.7""\n\n}\n\nAlso, Tracer supports gathering and analysis of native crashes. If you want to gather crashes that occurred on the native code, connect the relevant dependency (see below).\n\ndependencies {\n\nimplementation ""ru.ok.tracer:tracer-crash-report-native:0.2.7""\n\n}\n\nWarning\n\nCurrently, this feature is under active development. Crash logs gathering functions, however, native crashes are displayed without stack trace and other details. Now you can gather and count them while displaying and categorization are being tweaked.\n\nFor a detailed description of the dependencies see “Quickstart”.\n\nCrashReportConfiguration and CrashFreeConfiguration description In your Application.kt.\n\nclass MyApplication : Application(), HasTracerConfiguration { override val tracerConfiguration: List<TracerConfiguration>\n\nget() = listOf(\n\nCrashReportConfiguration.build {\n\n// your options\n\n}, CrashFreeConfiguration.build {\n\n// your options\n\n176\n\n},\n\n)\n\n}\n\nBelow are the CrashReportConfiguration.Builder options:\n\nsetEnabled — enables/disables crash reporting. By default: enabled. setSendAnr — disables ANR sending. By default: enabled. setNativeEnabled — enables/disables native crash reporting. The default value depends on whether the tracer-crash-report-native dependency is connected. If the dependency is connected, then, reporting is by default enabled. If not, disabled. ⚠ You cannot enable native crash reporting without connecting the relevant dependency but you can disable reporting if the dependency is connected.\n\nBelow are the CrashReportConfiguration.Builder options that are deprecated or dangerous.\n\nsetHost — deprecated and will be removed in version 0.3.x. If you really need to\n\nchange the host, use CoreTracerConfiguration.setHost;\n\nsetSendLogs — deprecated and does nothing, will be removed in version 0.3.x; setCountCrashFreeUsers — deprecated and does nothing, will be removed in\n\nversion 0.3.x; use CrashFreeConfiguration.Builder.setEnabled instead;\n\nsetSendThreadsDump, setSendAsap, setMaxNonFatalExceptions — deprecated\n\nand do nothing, will be deleted in version 0.3.x.\n\nBelow are the CrashFreeConfiguration.Builder options.\n\nsetEnabled — enables/disables crash free users count. By default: disabled!\n\nBelow are the CrashFreeConfiguration.Builder options that are deprecated or dangerous.\n\nsetExperimentalMaxSessionsToUpload — how many sessions to gather before\n\nsending a batch. By default: 10. For testing purposes only!\n\nsetExperimentalMaxSessionTimeSpanToUpload — for how long to gather\n\nsessions before sending a batch. By default: 4 hours (in milliseconds). For testing purposes only!\n\nsetExperimentalUploadSessionsFromYesterday — send a batch if yesterday\'s (or\n\nearlier) sessions are detected. By default: enabled.\n\nTracerCrashReport description To send non-fatals the TracerCrashReport.report(throwable) method is used.\n\n// Log a non-fatal error. TracerCrashReport.report(NonFatalException(""I\'ll be ok soon""))\n\n177\n\nCrashes are grouped by common parts of a stack trace. By default, non-fatals, however, tweak this grouping approach.\n\nYou can gather all non-fatals in one group regardless of a stack trace using the report method with the issueKey parameter.\n\n// Log a non-fatal error with the ISSUE-001 key TracerCrashReport.report(NonFatalException(""What a terrible failure""), issueKey = ""ISSUE-001"")\n\nWarning\n\nCurrently, Tracer has a limit of 1 million events a day. That is why the excessive use of this method is not recommended.\n\nYou can also add additional info to an event.\n\nHeap Dumps\n\nConnecting dependencies to your project In your <project>/<app-m,odule>/build.gradle.\n\ndependencies {\n\nimplementation ""ru.ok.tracer:tracer-heap-dumps:0']","Tracer supports gathering and analysis of native crashes. To gather and analyze native crashes using Tracer with enabled and configured crash reporting, you need to connect the relevant dependency 'tracer-crash-report-native:0.2.7' in your project. Once connected, native crash reporting is enabled by default. You can use the TracerCrashReport.report(throwable) method to log non-fatal errors. Crashes are grouped by common parts of a stack trace, but you can tweak this grouping approach by using the issueKey parameter in the report method. It is important to note that Tracer has a limit of 1 million events a day, so excessive use of the report method is not recommended.",multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To gather and analyze native crashes using Tracer with enabled and configured crash reporting, you need to follow these steps:

1. Connect the relevant dependencies in your project's build.gradle file:
   - Add the dependency for gathering crash reports: ""ru.ok.tracer:tracer-crash-report:0.2.7""
   - Add the dependency for gathering native crashes: ""ru.ok.tracer:tracer-crash-report-native:0.2.7""

2. Implement the necessary configurations in your Application.kt class by implementing the HasTracerConfiguration interface:
   - Define a list of TracerConfiguration objects that include CrashReportConfiguration and CrashFreeConfiguration.
   - Customize the options within the CrashReportConfiguration and CrashFreeConfiguration as needed.

3. By following the above steps, Tracer will be able to gather and analyze native crashes with enabled and configured crash reporting. Keep in mind that this feature is under active development, and the display and categorization of native crashes are being tweaked for better functionality.

If you need more detailed information or specific configuration options, you can refer to the provided documents for a more in-depth understanding of Tracer's crash reporting capabilities.","To gather and analyze native crashes using Tracer with enabled and configured crash reporting, you need to follow these steps:

1. **Connect Dependencies**:
   - Add the following dependencies to your project's `build.gradle` file:
     - `implementation ""ru.ok.tracer:tracer-crash-report:0.2.7""` for crash reporting.
     - `implementation ""ru.ok.tracer:tracer-crash-report-native:0.2.7""` for native crash reporting.

2. **Configure Crash Reporting**:
   - In your `Application.kt` file, implement the `HasTracerConfiguration` interface.
   - Define the tracer configuration by including `CrashReportConfiguration.build { // your options }`.
   - Use the following options in `CrashReportConfiguration.Builder`:
     - `setEnabled`: Enables or disables crash reporting (default: enabled).
     - `setSendAnr`: Disables ANR sending (default: enabled).
     - `setNativeEnabled`: Enables or disables native crash reporting. The default value depends on whether the `tracer-crash-report-native` dependency is connected.

3. **Analyze Native Crashes**:
   - Once configured, Tracer will gather and count native crashes.
   - Note that native crashes are displayed without a stack trace and other details, as this feature is under active development.
   - You can analyze the gathered native crashes while the display and categorization are being improved.

By following these steps and configuring Tracer with the necessary dependencies and options, you can gather and analyze native crashes using Tracer with enabled and configured crash reporting."
"What does the AttributionControl in map objects offer, and how can its display be customized?","[' method to determine the zoom level the map is set to. ● toFixed(), a JavaScript method that allows you to cut the resulting floating point number to a given number of digits.\n\nCoordinate display\n\n775\n\nWhen collecting and storing this information, you can use return to display it on the map. Inside the opening <div> tag created to store the map, add a new <div> to display the map longitude, latitude, and scale. Afterwards, the return will look like this:\n\nWith hooks return (\n\n<div>\n\n<div className=""sidebar"">\n\nLongitude: {lng} | Latitude: {lat} | Zoom: {zoom}\n\n</div>\n\n<div className=""map-container"" ref={mapContainer} />\n\n</div>\n\n);\n\nWith classes render() {\n\nconst { lng, lat, zoom } = this.state;\n\nreturn (\n\n<div>\n\n<div className=""sidebar"">\n\nLongitude: {lng} | Latitude: {lat} | Zoom: {zoom}\n\n</div>\n\n<div ref={this.mapContainer} className=""map-container"" />\n\n</div>\n\n);\n\n}\n\nApply a few styles to the sidebar for correct display on the page. Add the following CSS to site.css:\n\n.sidebar {\n\nbackground-color: rgba(35, 55, 75, 0.9);\n\ncolor: #ffffff;\n\npadding: 6px 12px;\n\nfont: 15px/24px monospace;\n\nz-index: 1;\n\nposition: absolute;\n\ntop: 0;\n\nleft: 0;\n\nmargin: 12px;\n\nborder-radius: 4px;\n\n}\n\n776\n\nClick “Save” and return to the browser page. The top left map corner has a sidebar styled according to the CSS rules set in site.css. The sidebar shows the current latitude and longitude of the map center, as well as the zoom level. As you zoom and move the map, the sidebar contents will be updated.\n\n777\n\nDescription of additional map objects\n\nAttributionControl\n\nThe AttributionControl control provides information about the map\'s attributes (copywriting, and so on).\n\nsrc/ui/control/attribution_control.js\n\nOptions: compact:boolean — if true, then it will always be displayed in a compact view, if false, it will always be in full size, by default it works depending on the map size (viewport < 640 ? compact : full ) customAttribution:string|Array<string> — string or strings to display in map attributes\n\nExample: var map = new mmrgl.Map({attributionControl: false})\n\n.addControl(new mmrgl.AttributionControl({\n\ncompact: true\n\n}));\n\nLngLatBoundsLike\n\nAn LngLatBounds object, an array of LngLatLike objects in the order [sw, ne], or an array of numbers in the order [west, south, east, north].\n\nsrc/geo/lng_lat_bound.js\n\nExample: var v1 = new mmrgl.LngLatBounds(\n\nnew mmrgl.LngLat(-73.9876, 40.7661),\n\nnew mmrgl.LngLat(-73.9397, 40.8002)\n\n);\n\nvar v2 = new mmrgl.LngLatBounds([-73.9876, 40.7661], [-73.9397,\n\n40.8002])\n\nvar v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n\n778\n\nStatic map\n\n/staticmap/png — service that allows you to get a map image.\n\nRequest\n\nRequired request parameters\n\nField name\n\nFormat\n\nDescription\n\napi_key\n\nhex-string\n\nSee “Access to services”\n\nlatlon\n\nfloat,float\n\nLatitude and longitude (in degrees) of the geometric center of the desired map image.\n\nLatitude and longitude are separated by commas .\n\nWhen specifying bbox in the request, the values specified in latlon are ignored\n\nbbox\n\nfloat,float,f loat,float\n\nObject area, which is described by a pair of coordinates in the order: lat1,lon1,lat2,lon2\n\nThe latitude and longitude of the coordinates are specified separated']","The AttributionControl in map objects provides information about the map's attributes, such as copywriting. Its display can be customized by setting options like compact (to control the size of the display) and customAttribution (to add custom strings to the map attributes). An example of customizing the display is by creating a new mmrgl.AttributionControl with specific options like compact: true.",multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The AttributionControl in map objects offers information about the map's attributes such as copywriting. It can be customized in the following ways:

1. **Options**:
   - **compact**: It can be set to true or false. If set to true, the AttributionControl will always be displayed in a compact view. If set to false, it will always be in full size. By default, it works depending on the map size (viewport < 640 ? compact : full).
   
   - **customAttribution**: It can be a string or an array of strings to display in the map attributes. This allows developers to add custom attribution information to the map.

2. **Example**:
   ```javascript
   var map = new mmrgl.Map({ attributionControl: false })
       .addControl(new mmrgl.AttributionControl({ compact: true }));
   ```

In summary, the AttributionControl in map objects provides a way to display information about the map's attributes, and developers can customize its display by setting the compact option and adding custom attribution strings.","The AttributionControl in map objects provides information about the map's attributes, such as copywriting details. It can be customized with the following options:

1. **compact (boolean):** If set to true, the control will always be displayed in a compact view. If set to false, it will always be in full size. By default, it adjusts based on the map size (viewport < 640 ? compact : full).

2. **customAttribution (string or Array<string>):** This option allows you to specify a custom string or an array of strings to display in the map attributes.

To implement the AttributionControl with custom settings, you can create a new map object and add the AttributionControl with the desired options. Here is an example code snippet:

```javascript
var map = new mmrgl.Map({ attributionControl: false })
  .addControl(new mmrgl.AttributionControl({
    compact: true
  }));
```

In this example, the AttributionControl is added to the map with the compact option set to true, which will display the control in a compact view. You can further customize the control by adding additional options like customAttribution if needed."
How can a company electronically sign a request with a Federal Tax Service e-signature matching the TIN and enable monetization for foreign companies on RuStore?,"[' is an electronic signature issued by the Federal Tax Service for your company. If you do not have an e-signature, contact a CEO, chief accountants, lawyers, HR specialists or procurement coordinators. Make sure that the employee with an EDS is entitled to sign financial documents. If in doubt, show them our Terms of Service.\n\nMonetization is available only to legal entities/individual entrepreneurs and application owners.\n\nHow to create and sign a request\n\nInstall the CryptoPro plugin to sign the request.\n\n1. Open the RuStore Console. 2. Click the ""Applications"" tab at the top of your screen. 3. Select ""Subscriptions"" in the left side menu, then go to the""Monetization"" section. 4. Click ""Fill out the form"".\n\nIf you accepted the terms before 12/22/2022, re-sign your application with an electronic signature.\n\n5. Fill in the data in the pop-up window. 6. Click ""Save and Continue"". 7. Read the payment terms for developers. 8. Click ""Create and Sign the request"".\n\n101\n\nSelect a signing certificate. The certificate must be issued on behalf of your company — we will check that the specified TIN matches the TIN of your company.\n\nYou can check your TIN in the certificate properties: in the operating system tools or in a certificate program (for example, CryptoPro).\n\nClick ""Sign a request"". It may take a few seconds to sign your request.\n\nOnce there, you can download the approved monetization request. Click ""Download a PDF-request"". Request example\n\n102\n\n103\n\nTest payments\n\nBackground\n\nYou can now test payments for subscriptions and in-app billing in your apps. The test purchase is carried out as a regular payment, though using test bank cards.\n\nFunctionality\n\nThe Test Payments function provides the following options:\n\nTest mode control via RuStore Console. ● Testing of payment scenarios in your app, which is carried out in an isolated test environment using special test cards and without affecting the release app version.\n\nView test payments history in RuStore Console.\n\nTechnical specifications\n\nYou can perform testing before publishing an app version to all users. ● In test mode, you can purchase the same products and subscriptions that were added to the release app version. At that, it is not necessary to publish them.\n\nYou can test the purchase of non-consumable items repeatedly (for example, access to the full app version or a skin in a game). To do that, you can return the payment via RuStore Console, and then make a purchase again in the application.\n\nIn test mode, special parameters are applied to subscriptions. They are independent of and do not affect the settings you select for the release app version. These technical features are designed to simplify and speed up testing.\n\nThe parameters in the table below are the same for all subscriptions in test mode.\n\nParameter\n\nValue\n\nMaximum number of subscription charges. After completing\n\n12\n\nthe specified number of debits, the subscription is\n\nautomatically closed\n\nPeriod between subscription charges\n\n10 mins\n\nOnce in 3 hours\n\nFrequency of resetting the free and starting period (purchase of subscriptions with a free and starting period). After the reset, you will again be able to purchase a subscription for free or at the initial price. This way you can test payment for a\n\n104\n\nsubscription several times under special conditions.\n\nRestrictions\n\nThe application owner is the only user who can test payments. He has exclusive access to the Test Payments section. Options to add other testers are now under development.\n\nTesting of a paid app purchase is not available in RuStore. ● The RuStore app does not display the history of test purchases and test subscriptions. This means that test subscriptions cannot be canceled or renewed.\n\nYou can pay for test purchases using test bank cards only. ● To test payments, at least the first app version must be moderated.\n\nBefore you start testing payments\n\nIntegrate the SDK that supports the payment testing function into the tested app —\n\nRuStore SDK billingclient 3.1.0 or higher.\n\nMake sure that the Android device on which you plan to test your app has RuStore\n\nversion 1.29 or higher installed.\n\nMake sure that your company is not blocked, that it has monetization enabled, and supports payment functionality in the app. You can set up subscriptions and paid products in RuStore Console, but not publish them to users.\n\nSee also\n\nHow to enable monetization - How to create a paid in-app product - How to create an app subscription\n\nEnable Test Mode\n\nYou can test payments after moderation is completed and before you publish a new app version'
 ""Store Console. 2. Select Applications from the top menu. 3. Go to the Monetization → Test Payments tab. 4. Switch to the Testers tab. 5. Deactivate the switch in the Test Mode section.\n\nOnce you disable the test mode:\n\nThe tester starts making real in-app purchases. ● All payments made in test mode are saved in RuStore Console on the Payment History tab.\n\nPurchased paid products remain available to your account the next time you turn on test\n\nmode.\n\nTest subscriptions will be disabled automatically after 12 charges.\n\nFurther steps\n\nOnce you've tested payments to ensure they operate properly, you can publish subscriptions and paid items to your app, and then publish a new app version.\n\n110\n\nTest Bank Cards\n\nTo test purchases, you can use the following test cards.\n\nAlways successful\n\nCard number\n\n4111 1111 1111 1111\n\nECI\n\n05\n\nCVC\\CVV\n\n123\n\nExpiration date\n\n2024/12\n\n3-D Secure verification code\n\n12345678\n\nCard number\n\n5100 0000 0000 0008\n\nECI\n\n05\n\nCVC\\CVV\n\n123\n\nExpiration date\n\n2024/12\n\n3-D Secure verification code\n\n12345678\n\nThe buyer is offered to select the 3-D Secure verification result.\n\nCard number\n\n2201 3820 0000 0013\n\nECI\n\n02\n\nCVC\\CVV\n\n123\n\nExpiration date\n\n2024/12\n\n111\n\nReturns errors\n\nAfter three unsuccessful payment attempts, the payment will be returned to the RuStore payment system with a payment error.\n\nCard number\n\n5100 0000 0000 0180\n\nECI\n\n00\n\nCVC\\CVV\n\n123\n\nExpiration date\n\n2024/12\n\nCard number\n\n4444 4444 4444 4422\n\nCVC\\CVV\n\n123\n\nExpiration date\n\n2024/12\n\nCard number\n\n4444 4444 1111 1111\n\nCVC\\CVV\n\n123\n\nExpiration date\n\n2024/12\n\nCard with 1 kopeck balance\n\nCard number\n\n4954 8493 9714 9582\n\nCVC\\CVV\n\n123\n\nExpiration date\n\n2024/12\n\n3-D Secure verification code\n\n12345678\n\n112\n\nMonetization for foreign companies on RuStore\n\nForeign companies that are registered within RuStore can now enable monetization and receive income from both paid applications or in-app purchases, including subscriptions.\n\nMonetization is available under the terms of a standard Additional agreement. The actual settlement currency will be displayed in the form when submitting the monetization request.\n\nCreate and fill out a monetization request\n\n1. Open the RuStore Console. 2. Click the Company tab at the top of your screen. 3. Select Monetization in the left side menu. 4. Then click Apply for monetization.\n\n113\n\n5. Fill in the data in the new window.\n\nGeneral info. The Trade and legal name field is filled out by default\n\naccording to your constituent documents. If the data is incorrect, contact support and submit a new request once you fill in the correct data.\n\nNote. We may ask you to verify your rights to the specified trade name. You are not required to have your rights legally registered, however, in this case, we will ask you to ensure that the use of this trade name does not violate the rights of third parties.\n\n1. Signatory differs from company owner.\n\nIf the representative is different from the company owner on RuStore, fill in the information according to the representative authority document. Attach the decision on appointment, power of attorney, etc. Make sure that the person who will sign the Additional agreement on behalf of your company is indicated here.\n\n114\n\n2. Company information\n\nMake sure that Tax number and Legal address match the information in\n\n\n\nyour constituent documents. If the legal address does not match the actual one, you must also indicate the actual address where the company operates.\n\n115\n\n3. Contacts for user feedback\n\nNote. The RuStore support service can send these contacts to users or publish them on the app page.\n\nWhen filling in the Contact person section, specify the up-to-date contact\n\n\n\ndetails so that users can get back to you quickly regarding app support, as well as financial claims (refund / payment cancellation requests, fraudulent payments notifications). The Phone Number and Email sections are intended for internal communications with RuStore and will be""]","To electronically sign a request with a Federal Tax Service e-signature matching the TIN and enable monetization for foreign companies on RuStore, follow these steps: 1. Install the CryptoPro plugin to sign the request. 2. Open the RuStore Console and click on the Company tab. 3. Select Monetization from the left side menu and click Apply for monetization. 4. Fill in the required data in the new window, ensuring that the Tax number and Legal address match the information in your constituent documents. 5. Sign the Additional agreement with the e-signature issued by the Federal Tax Service, ensuring it matches the TIN of your company.",multi_context,"[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}, {'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}]",True,"To electronically sign a request with a Federal Tax Service e-signature matching the TIN and enable monetization for foreign companies on RuStore, the following steps need to be taken:

1. Ensure that the company is registered within RuStore.
2. Open the RuStore Console.
3. Click the Company tab at the top of the screen.
4. Select Monetization in the left side menu.
5. Click Apply for monetization.
6. Fill out the monetization request form that appears on the screen.
7. The actual settlement currency will be displayed in the form during the submission of the monetization request.
8. Install the CryptoPro plugin to sign the request electronically.
9. Follow the instructions provided by RuStore to fill in the data in the pop-up window.
10. Click ""Save and Continue"" after filling in the required information.
11. Read and accept the payment terms for developers.
12. Click ""Create and Sign the request"" to electronically sign the monetization request with the Federal Tax Service e-signature matching the TIN.

By following these steps, a company can electronically sign a request with a Federal Tax Service e-signature matching the TIN and enable monetization for foreign companies on RuStore.","To electronically sign a request with a Federal Tax Service e-signature matching the TIN and enable monetization for foreign companies on RuStore, follow these steps:

1. Open the RuStore Console in your browser.
2. Click Sign in to RuStore Console.
3. Select Legal entity.
4. You will need an enhanced qualified e-signature and the Crypto plugin.
5. Click Sign in with VK ID.
6. Enter the phone number linked to your VK ID or create a new account. You can use international phone numbers to create an account.
7. Click Continue.
8. Click Create Account.
9. Fill in all the required fields, including the trade name, legal name, contact person details, and Tax or registration number matching the information in your constituent documents.
10. In the Documents section, attach all the required documents in English or Russian, including company establishment documents, partner representative's authority documents, and partner’s domain name/trademark/logo registration certificate.
11. Submit the application for monetization.

Please note that the Crypto Pro plug-in is only required for Russian companies. If you are a foreign company, you will need an enhanced qualified e-signature instead.

If you have any questions or need further assistance, feel free to ask."
"How should AnyApp developer manage incomplete payments in terms of cancellation and consumption, based on purchase status and payment results?","['Uncompleted payments must be processed by the AnyApp developer.\n\nThe purchase cancellation method should be used if:\n\n1. The method of getting the list of products returned the purchase status as follows:\n\nPurchaseState.CREATED; ○ PurchaseState.INVOICE_CREATED;\n\nNote. In some cases, after paying through a banking app (SBP, SberPay, TinkoffPay, etc.), the purchase status may still return PurchaseState.INVOICE_CREATED when you subsequently return to AnyApp. This is caused by the purchase processing time by the bank. Therefore, the developer needs to correctly link the shopping list obtaining function to the life cycle on the screen.\n\nTo solve this problem, you can cancel a purchase in the PurchaseState.INVOICE_CREATED status only through user interaction with the application. For example, create a separate button for this purpose.\n\n2. The purchase method (purchaseProduct) returned PaymentResult.Cancelled.\n\n3. The purchase method (purchaseProduct) returned PaymentResult.Failure.\n\nUse product consumption method (confirmPurchase) if the method the purchase obtaining method (getPurchases) returns a CONSUMABLE product and with the status PurchaseState.PAID.\n\n209\n\nEvent Logging\n\nIf you want to log payment library events when calling RuStoreBillingClient.init add externalPaymentLoggerFactory and debugLogs parameters (these parameters are optional for initialization):\n\nval billingClient: RuStoreBillingClient = RuStoreBillingClientFactory.create(\n\ncontext = app, consoleApplicationId = ""111111"", deeplinkScheme = ""yourappscheme"", externalPaymentLoggerFactory = { tag -> PaymentLogger(tag) }, debugLogs = true\n\n)\n\nclass PaymentLogger(private val tag: String) : ExternalPaymentLogger {\n\noverride fun d(e: Throwable?, message: () -> String) {\n\nLog.d(tag, message.invoke(), e)\n\n}\n\noverride fun e(e: Throwable?, message: () -> String) {\n\nLog.e(tag, message.invoke(), e)\n\n}\n\noverride fun i(e: Throwable?, message: () -> String) {\n\nLog.i(tag, message.invoke(), e)\n\n}\n\noverride fun v(e: Throwable?, message: () -> String) {\n\nLog.v(tag, message.invoke(), e)\n\n}\n\noverride fun w(e: Throwable?, message: () -> String) {\n\nLog.w(tag, message.invoke(), e)\n\n}\n\n}\n\nLogging processing parameters:\n\nexternalPaymentLoggerFactory — interface that allows you to create a logger that\n\nsends the library logs to the host application;\n\n210\n\ndebugLogs — enable logs (logs will be automatically disabled for Release builds).\n\nWhere PaymentLogger — example of payment event logging implementation.\n\n211\n\nTheme Changing\n\nThe SDK supports dynamic theme changing via the BillingClientThemeProvider provider\n\ninterface:\n\nval billingClient: RuStoreBillingClient =\n\nRuStoreBillingClientFactory.create(\n\ncontext = app,\n\nconsoleApplicationId = ""111111"",\n\ndeeplinkScheme = ""yourappscheme"",\n\nthemeProvider? = BillingClientThemeProviderImpl(),\n\n)\n\nclass BillingClientThemeProviderImpl: BillingClientThemeProvider {\n\noverride fun provide(): BillingClientTheme {\n\nval darkTheme = ....\n\nif(darkTheme){\n\nBillingClientTheme.Dark\n\n} else {\n\nBillingClientTheme.Light\n\n}\n\n}\n\n}\n\nError handling\n\nPossible errors:\n\nRuStoreNotInstalledException() — RuStore is not installed on the user\'s device; ● RuStoreOutdatedException() — RuStore, installed on the user\'s device, does not support payment processing functions;\n\nRuStoreUserUnauthorizedException() — user is not authorized on the RuStore; ● RuStoreApplicationBannedException() — your application is blocked on the RuStore;\n\nRuStoreUserBannedException() — user is blocked on the RuStore; ● RuStoreException(message: String) — basic RuStore error, from which all other errors are inherited.\n\n212\n\nWhen calling the RuStoreBillingClient.purchases.purchaseProduct() method, errors are handled automatically.\n\nYou can use the resolveForBilling method to show an error dialog to the user:\n\n']","The AnyApp developer should process uncompleted payments by using the purchase cancellation method in the following scenarios: 1. If the method of getting the list of products returns the purchase status as PurchaseState.CREATED or PurchaseState.INVOICE_CREATED, the developer should link the shopping list obtaining function to the life cycle on the screen and create a separate button for canceling the purchase. 2. If the purchase method (purchaseProduct) returns PaymentResult.Cancelled or PaymentResult.Failure. Additionally, the developer should use the product consumption method (confirmPurchase) if the purchase obtaining method (getPurchases) returns a CONSUMABLE product with the status PurchaseState.PAID.",multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To manage incomplete payments in terms of cancellation and consumption, the AnyApp developer should follow these guidelines based on the purchase status and payment results:

1. **Cancellation**:
   - The developer should use the purchase cancellation method (deletePurchase) in the following scenarios:
     - If the method of getting the list of products (getPurchases) returned the purchase status as PurchaseState.CREATED or PurchaseState.INVOICE_CREATED.
     - Note that in some cases, after paying through a banking app, the purchase status may still return PurchaseState.INVOICE_CREATED due to processing time by the bank. In such cases, the developer needs to link the shopping list obtaining function to the screen's life cycle and allow purchase cancellation in the PurchaseState.INVOICE_CREATED status only through user interaction with the application.
     - For example, the developer can create a separate button for this purpose.

2. **Consumption**:
   - The developer should use the product consumption method (confirmPurchase) in the following scenario:
     - If the method of obtaining the purchase (getPurchases) returns a CONSUMABLE product with the status PurchaseState.PAID.
   
3. **Payment Results**:
   - If the purchase method (purchaseProduct) returns PaymentResult.Cancelled, the developer should consider using the purchase cancellation method.
   - If the purchase method (purchaseProduct) returns PaymentResult.Failure, the developer should also consider using the purchase cancellation method.

By following these guidelines based on the purchase status and payment results, the AnyApp developer can effectively manage incomplete payments in terms of cancellation and consumption.","To manage incomplete payments in terms of cancellation and consumption, the AnyApp developer should follow these guidelines based on the purchase status and payment results:

1. **Cancellation Scenario**:
   - If the method of getting the list of products (getPurchases) returned the purchase status as PurchaseState.CREATED or PurchaseState.INVOICE_CREATED, the developer should consider canceling the purchase.
   - Note: In some cases, after paying through a banking app (SBP, SberPay, TinkoffPay, etc.), the purchase status may still return PurchaseState.INVOICE_CREATED when you subsequently return to AnyApp due to the processing time by the bank. In such cases, the developer needs to link the shopping list obtaining function to the screen's lifecycle correctly.
   - To cancel a purchase in the PurchaseState.INVOICE_CREATED status, user interaction with the application is required. For example, the developer can create a separate button for this purpose.
   - The purchase method (purchaseProduct) should be used if it returns PaymentResult.Cancelled or PaymentResult.Failure.

2. **Consumption Scenario**:
   - Use the product consumption method (confirmPurchase) if the method of obtaining purchases (getPurchases) returns a CONSUMABLE product with the status PurchaseState.PAID.

By following these guidelines, the AnyApp developer can effectively manage incomplete payments by canceling or consuming purchases based on the purchase status and payment results."
"How can an interactive map of Leningradsky Prospekt, 39 b79 in Moscow, Russia be embedded on a website or app?","[' ID is not fixed and can be changed from time to time\n\ntype\n\nstring\n\nObject type\n\nname\n\nstring\n\nObject name\n\naddress_details fields description\n\nField name\n\nFormat\n\nDescription\n\n""name"": ""Leningradsky\n\nProspekt, 39 b79"",\n\n}\n\n]\n\n""address"": ""Russia, Moscow, Northern Administrative District, Moscow, Khoroshevsky, Leningradsky Prospekt, 39 b79"",\n\n""address_details"": {\n\n""building"": ""39 b79"", ""country"": ""Russia"", ""isocode"": ""RU"", ""locality"": ""Moscow"", ""region"": ""Moscow"", ""street"": ""Leningradsky\n\nProspekt"",\n\n""subregion"": ""Northern\n\nAdministrative District"",\n\n""suburb"": ""Khoroshevsky""\n\n}\n\n""ref"": ""1000000C4D63818""\n\n""type"": ""building""\n\n""name"": ""Leningradsky Prospekt, 39 b79""\n\nExample\n\n640\n\ncountry\n\nstring\n\nCountry\n\n""country"": ""Russia""\n\nisocode\n\n2char\n\n2-character code according to ISO 3166-1 alpha-2\n\n""isocode"": ""RU""\n\nregion\n\nstring\n\nRegion\n\n""region"": ""Moscow""\n\nsubregion\n\nstring\n\nSubregion\n\n""subregion"": ""Northern Administrative District""\n\nlocality\n\nstring\n\nLocality\n\n""locality"": ""Moscow""\n\nsublocality\n\nstring\n\nSublocality or community\n\n""sublocality"": ""Airport""\n\nstreet\n\nstring\n\nStreet\n\n""street"": ""Leningradsky""\n\nbuilding\n\nstring\n\nHouse, building\n\n""building"": ""39 b80""\n\nsuburb\n\nstring\n\nSuburb/neighborhood\n\n""suburb"": ""Khoroshevsky""\n\npostal_code\n\nstring\n\nPostal code\n\n""postal_code"": ""125167""\n\nExample\n\nRequest\n\nhttps://geo.rustore.ru/api/suggest?api_key=<YOUR_API_KEY>&limit=3&q=Mo\n\nscow%20Leningradsky%2039\n\nResponse\n\n641\n\n{\n\n""request"": ""/suggest?limit=2&q=Moscow Leningradsky\n\n39&api_key=demo_demo_main"",\n\n""results"": [\n\n{\n\n""address"": ""Russia, Moscow, Northern Administrative District,\n\nMoscow, Khoroshevsky, Leningradsky Prospekt, 39 79"",\n\n""name"": ""Leningradsky Prospekt, 39 79"",\n\n""type"": ""building""\n\n},\n\n{\n\n""address"": ""Russia, Moscow, Northern Administrative District,\n\nMoscow, Khoroshevsky, Leningradsky Prospekt, 39 b80"",\n\n""name"": ""Leningradsky Prospekt, 39 b80"",\n\n""type"": ""building""\n\n},\n\n{\n\n""address"": ""Russia, Moscow, Northern Administrative District,\n\nMoscow, Khoroshevsky, Leningradsky Prospekt, 39 3"",\n\n""name"": ""Alexander Gomelsky Universal Sports Hall CSKA"",\n\n""type"": ""building""\n\n}\n\n]\n\n}\n\n642\n\nMap display services\n\nMap display services are designed to help you embed an interactive and static map into your products.\n\nAn interactive map — service that allows you to embed a map on a website or app, enabling the user to change the scale, angle and position of the display, as well as to add various elements to the map using JS: pins, curves, highlighting, etc.\n\nA static map — service that allows you to get a map image with pins placed on it as a PNG or JPG image.\n\nServices\n\nCall point\n\nDescription\n\nInteractive map\n\n/staticmap\n\nStatic map\n\n643\n\nInteractive map\n\nQuick start 1. Map 2. Properties and options 3. Tags and controls 4. Geography and geometry 5. Handlers 6. Sources 7. Events 8. How to use the library in React applications Description of additional map objects\n\nThe following components are required to display an interactive map:\n\ndisplay data (tiles); ● display style; ● map'
 '.539105, 55.796639\n\n], [\n\n37.539082, 55.796674\n\n], [\n\n37.539052, 55.796705\n\n], [\n\n37.53901, 55.796737\n\n], [\n\n37.538958, 55.796763\n\n], [\n\n37.538899, 55.796784\n\n], [\n\n37.538835, 55.796801\n\n], [\n\n37.538772, 55.796808\n\n625\n\n], [\n\n37.538714, 55.79681\n\n], [\n\n37.538416, 55.79694\n\n], [\n\n37.538253, 55.796822\n\n]\n\n]\n\n], ""type"": ""Polygon""\n\n}\n\ntype\n\nstring\n\nObject type\n\n""type"": ""building""\n\naddress_details fields description\n\nField name Forma\n\nDescription\n\nExample\n\nt\n\ncountry\n\nstring\n\nCountry\n\n""country"": ""Russia""\n\nisocode\n\n2char\n\n2-character code according to ISO 3166-1 alpha-2\n\n""isocode"": ""RU""\n\nregion\n\nstring\n\nRegion\n\n""region"": ""Moscow""\n\nsubregion\n\nstring\n\nSubregion\n\n""subregion"": ""Northern Administrative District""\n\nlocality\n\nstring\n\nLocality\n\n""locality"": ""Moscow""\n\n626\n\nsublocality\n\nstring\n\nSublocality or community\n\nstreet\n\nstring\n\nStreet\n\nbuilding\n\nstring\n\nHouse, building\n\nsuburb\n\nstring\n\nSuburb/neighborhood\n\npostal_code\n\nstring\n\nPostal code\n\ngeometry fields description\n\nField name Format\n\nDescription\n\ntype\n\nstring\n\nGeometry type:\n\nPoint — point; ● MultiPoint — multiple points;\n\nLinestring — line; ● MultiLineString — multiple lines;\n\nPolygon — polygon; ● MultiPoligon — multiple polygons.\n\ncoordinates\n\nlist\n\nPoint array (longitude and latitude) that describe the object geometry\n\n""sublocality"": ""Airport""\n\n""street"": ""Leningradsky Prospekt""\n\n""building"": ""39 b80""\n\n""suburb"": ""Khoroshevsky""\n\n""postal_code"": ""125167""\n\nExample\n\n""type"": ""Polygon""\n\n""coordinates"": [\n\n[100.0, 0.0], [101.0,\n\n0.0],\n\n[101.0, 1.0], [100.0,\n\n1.0],\n\n[100.0, 0.0]\n\n]\n\n627\n\nIn case of zero request result, the response will show the following:\n\n{\n\n""results"": [],\n\n""request"": ""/v3/search?limit=1&q=ascec""\n\n}\n\nExample\n\nDirect geocoding\n\nRequest\n\nhttps://geo.rustore.ru/api/search?api_key=<YOUR_API_KEY>q=Moscow%20Len\n\ningradsky%2039%20с14&fields=address_details,address,pin,bbox,geometry,\n\ntype&limit=1\n\nResponse\n\n{\n\n""request"": ""/search?api_key=demo_demo_main&limit=1&q=Moscow\n\nLeningradsky 39\n\nс14&fields=address_details,address,pin,bbox,geometry,type"",\n\n""results"": [\n\n{\n\n""address"": ""Russia, Moscow, Northern Administrative District,\n\nMoscow, Khoroshevsky, Leningradsky Prospekt, 39 b14"",\n\n""address_details"": {\n\n""building"": ""39 с14"",\n\n""country"": ""Russia"",\n\n""postal_code"": ""125167"",\n\n628\n\n""isocode"": ""RU"",\n\n""locality"": ""Moscow"",\n\n""region"": ""Moscow"",\n\n""street"": ""Leningradsky Prospekt"",\n\n""subregion"": ""Northern Administrative District"",\n\n""suburb"": ""Khoroshevsky""\n\n},\n\n""bbox"": [\n\n37.538253,\n']","To embed an interactive map of Leningradsky Prospekt, 39 b79 in Moscow, Russia on a website or app, you can use the /staticmap service provided by map display services. This service allows you to embed a map that enables users to change the scale, angle, and position of the display, as well as add various elements like pins and curves using JavaScript.",multi_context,"[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}, {'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}]",True,"To embed an interactive map of Leningradsky Prospekt, 39 b79 in Moscow, Russia on a website or app, you can use the reverse geocoding API provided by Rustore. By making a request to the API with the coordinates of the location (55.796668, 37.538871), you can retrieve detailed address information including the street name, building number, country, region, and locality.

Once you have the address details, you can use mapping libraries like Google Maps API or Mapbox to display the location on an interactive map. These mapping libraries allow you to customize the map style, add markers, and provide interactive features like zooming and panning.

In this case, the address details for Leningradsky Prospekt, 39 b79 in Moscow, Russia are as follows:
- Country: Russia
- Region: Moscow
- Locality: Moscow
- Subregion: Northern Administrative District
- Suburb: Khoroshevsky
- Street: Leningradsky Prospekt
- Building: 39 b79

You can use this information to center the map on the specific location and add a marker to indicate the building at Leningradsky Prospekt, 39 b79 in Moscow, Russia on your website or app.","To embed an interactive map of Leningradsky Prospekt, 39 b79 in Moscow, Russia on a website or app, you can follow these steps:

1. **Add JS & CSS files from SDK**: You need to add JavaScript and CSS files from the SDK provided. These files are essential for the functionality of the interactive map.

2. **Initialize the map**: Add the map initialization code to your project, specifying the current API access key. This key is required to access the map services.

3. **Specify the required style**: You must specify the style you want for the map. You can choose from different styles such as light_style.json, mapsme_style.json, or main_style.json.

4. **Add objects to the map**: If you want to add custom objects to the map, you need to describe their coordinates using GeoJson. This allows you to place pins, curves, or other elements on the map.

By following these steps, you can embed an interactive map of Leningradsky Prospekt, 39 b79 in Moscow, Russia on your website or app."
"What details are needed for the company bank account in the monetization process, and how can users give feedback on financial app matters?","["" visible to users. Please enter the international phone number in the Representative number field.\n\nYou can also specify the preferred method of communication and add a link to instant messengers, a feedback form, or another tool used to receive feedback from users (optional). We also recommend checking the availability of this tool for users from the Russian Federation.\n\n116\n\n4. Contract information\n\nCompany's chief accountant full name. - Accounting statements: income statement, balance sheet. - Documents confirming tax residency. A tax residency certificate is provided to avoid double taxation. Going forward, we will ask you to update this document annually.\n\n117\n\n5. Bank details.\n\nProvide the company bank account details in either a Russian or foreign\n\nbank, where the settlements will be processed.\n\nNote. If there is no currency listed which would be convenient for you to make payments, please contact support@rustore.ru and we will consider your offer.\n\n118\n\n\n\nIf you want to make payments through a specific correspondent bank, please specify the required details in this section. We will send your income to these details for further transfer to you. Otherwise, we will transfer your income to the details specified above through our standard correspondent bank.\n\n119\n\nThe Additional agreement outlines the process for currency conversion during payment.\n\nNote. RuStore charges a fee on paid apps and in-app items (subscriptions, in-app purchases). The fee for non-residents is 15%. In cases where RuStore is required to be a tax agent of a non-resident, apart from the fee, the amount of taxes payable in accordance with the legislation of the Russian Federation will be withheld.\n\n6. Click Submit a request. 7. Check the request text and click Go to submit. Your monetization request will be reviewed and approved by a moderator.\n\nNote. You can withdraw the request at any stage and make the necessary changes whenever so required, and then re-submit for review.\n\nAttention. In case of discrepancy, we will notify you by email and ask you to attach the correct documents, while we reserve the right to reject the request and / or either block the monetization option in exceptional circumstances.\n\nOnce you have submitted the moderation request, we will send the Additional agreement to your email. Read the agreement and sign it to enable monetization.\n\n120\n\nNote. Please note that the Supplementary Agreement must be signed by the person whose information you have indicated in the Company Representative section above.\n\nOnce monetization is enabled for you, you will be able to set up subscriptions, in-app products and publish paid apps. You will receive a monthly report on accepted payments. We will transfer payments to you in accordance with the Additional agreement.\n\nPayments are scheduled once a month at most, provided that the minimum amount has been reached since the previous payment.\n\n121\n\nPayments management\n\nIn RuStore Console you can monitor payments per monetization-enabled app.\n\nViewing payments information\n\n1. Open RuStore Console.\n\n2. Select Applications in the top menu.\n\n3. From the menu on the left select Monetization > Payment management.\n\nThe payment information table is displayed only if the app was purchased at least once. The table contains:\n\ndate and time of a purchase; ● invoice number and order number; ● payment card number and phone number from which the payment was made; ● purchase amount; ● invoice status.\n\nOnly subscription payments have order number. Order number is the same for all payments of a subscription.\n\nClick on a payment to see the detailed information.\n\n122\n\nPayment search\n\nTo search and view payment information, follow these steps:\n\n1. Open RuStore Console. 2. Select Applications in the top menu. 3. From the menu on the left select Monetization > Payment management. 4. Enter the invoice number in the search field. The payment amount and status information will be displayed. Select one of the identifiers as a search criteria — invoice number or order number. After that, enter the invoice or order number in the search field accordingly. In the search results, you'll see all in-app payments that match the selected search criteria.\n\n123\n\nA payment can have one of the following statuses:\n\nProcessing: the money on the buyer's payment card is put on hold. The purchase is waiting to be confirmed.\n\nCanceled: the money on the buyer's payment card is released from hold. The purchase is canceled.\n\nPaid: transaction confirmed, the funds are debited from the buyer's account.\n\nRefunded: the funds are returned to the buyer's account. The refund time may be up to 5 business days.\n\nPayment return\n\nTo return a payment to the buyer, follow these steps:\n\n1. Open""]",Provide the company bank account details in either a Russian or foreign bank for the monetization process. Users can give feedback on financial app matters by contacting support@rustore.ru.,multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"In the monetization process, the company will need to provide details for their bank account. This information is necessary for receiving payments from the monetization of their app. Users can give feedback on financial app matters by receiving a monthly monetization report by mail. This report includes details such as the company's debt at the beginning of the reporting period, payments accepted from app users, and debt payable to the company. Additionally, if the company has a debt to the company from the previous report, an invoice will be sent to be paid within 3 business days from the date of receipt.","In the monetization process on RuStore, the following details are needed for the company bank account:

1. Beneficiary Bank name
2. Beneficiary Bank address
3. Beneficiary Bank account number (or IBAN if applicable)
4. BIC/SWIFT/ABA/Another Bank Identifier
5. Beneficiary Bank correspondent account number

Additionally, if specific correspondent bank details are required for payments, users can specify those details, and RuStore will send the income to those details for further transfer.

Regarding giving feedback on financial app matters, users can provide feedback through the following channels:

- E-mail: Users can send their feedback and financial app matters to the provided email address.
- Phone number: Users can contact the provided phone number for support and assistance with financial app matters.
- Address: Users can also reach out via mail to the provided address for any financial app-related issues.

These contact details are intended for users to quickly get in touch regarding app support, financial claims (like refund or payment cancellation requests), and notifications of fraudulent payments."
How to integrate RuStore AppUpdate SDK in Unreal Engine and Unity?,"['ULTICAST_DELEGATE_TwoParams(FRuStoreOnStateUpdatedIn stanceDelegate, int64, listenerId, FURuStoreInstallState, state); UPROPERTY(BlueprintAssignable, Category = ""RuStore AppUpdate Manager"") FRuStoreOnStateUpdatedInstanceDelegate OnStateUpdatedInstanceEvent;\n\nBlueprint implementation:\n\n566\n\nOn receiving EURuStoreInstallStatus::DOWNLOADED, in the installStatus field, you can call the update installation method.\n\nUpdate installation\n\nAfter downloading the APK update file, you can start the update installation. To start the update installation call the CompleteUpdate() method.\n\n|CompleteUpdate() call example requestId = CompleteUpdate(\n\n[](long requestId, TSharedPtr<FURuStoreError,\n\nESPMode::ThreadSafe> error) {\n\n// Process error\n\n}\n\n);\n\nBlueprint implementation:\n\nThe update is done via the native Android tool. If the update is successful, the app will close.\n\nThe Failure callback returns the FURuStoreError structure with the error information in the Error parameter. All possible FURuStoreException errors are described in the “Error handling” section.\n\nPossible errors\n\nWe do not recommend display an error to the user if you receive Failure in response. It can negatively affect the user experience.\n\nError structure:\n\nError structure USTRUCT(BlueprintType) struct RUSTORECORE_API FURuStoreRuStoreError {\n\nGENERATED_USTRUCT_BODY()\n\nFURuStoreRuStoreError() {\n\nname = """"; description = """";\n\n}\n\nUPROPERTY(BlueprintReadOnly) FString name;\n\nUPROPERTY(BlueprintReadOnly) FString description;\n\n};\n\nList of possible errors:\n\nRuStoreNotInstalledException — RuStore is not installed on the user\'s device. ● RuStoreOutdatedException — the RuStore app installed on the user\'s device doesn\'t support updates.\n\nRuStoreUserUnauthorizedException — the user is not authorized in RuStore.\n\n567\n\nRuStoreException — base RuStore error from which all other errors are inherited. ● RuStoreInstallException - Download and installation error.\n\nRuStoreInstallException error codes:\n\nERROR_UNKNOWN - Unknown error. ● ERROR_DOWNLOAD - Download error. ● ERROR_BLOCKED - Installation blocked by the systems. ● ERROR_INVALID_APK - Invalid update APK. ● ERROR_CONFLICT - There is a conflict with the current app version. ● ERROR_STORAGE - Not enough memory on the device. ● ERROR_INCOMPATIBLE - incompatible with the device. ● ERROR_APP_NOT_OWNED - The app is not purchased. ● ERROR_INTERNAL_ERROR - Internal error. ● ERROR_ABORTED - The user aborted the initialization. ● ERROR_APK_NOT_FOUND - APK for installation not found. ● ERROR_EXTERNAL_SOURCE_DENIED - Installation start denied. For example, the first request returned response that the update is unavailable, despite that, the user calls the second method.\n\nERROR_ACTIVITY_SEND_INTENT - Error while sending intent for opening an\n\nactivity.\n\nERROR_ACTIVITY_UNKNOWN - Unknown error on activity opening.\n\n568\n\nUnity\n\nGeneral Information Importing SDK to your project Creating an Update Manager Checking for updates Downloading updates Installing updates Handling errors\n\n309 310 311 312 314 317 318\n\n569\n\nGeneral Information\n\nRuStore In-app updates SDK enable users to be kept up to date with the latest app version on their device. This allows them to stay informed about any performance enhancements or bug fixes that have been implemented.\n\nMoreover, the SDK offers the ability to notify users of a new version and provide an option to install it. The installation process can occur in the background, while the user can track the progress of the update.\n\nUse case example\n\nConditions for correct operation of SDK\n\nFor RuStore In-app updates SDK to operate correctly, the following conditions need to be met:\n\n1. Android 7.0 or later. 2. The RuStore app is installed on the user\'s device. 3. The current RuStoreApp version is installed on the user\'s device. 4. The user has logged in to the RuStore. 5. The RuStore app is allowed to install applications.\n\n570\n\nImporting SDK to your project\n\nTo connect the SDK, you need to download RuStore AppUpdate SDK and import it into the project.']",The RuStore AppUpdate SDK can be integrated into Unreal Engine and Unity by downloading the SDK and importing it into the project.,multi_context,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"To integrate the RuStore AppUpdate SDK in Unreal Engine, you need to follow these steps:

1. Download the Unreal Engine plugins RuStoreCore and RuStoreAppUpdate from the official RuStore git repository.
2. Place the downloaded plugins in the Plugins folder inside your Unreal Engine project.
3. In Unreal Engine, go to Edit -> Plugins -> Project -> Mobile to see the RuStoreCore and RuStoreAppUpdate plugins.
4. Connect the RuStoreCore and RuStoreAppUpdate modules in the PublicDependencyModuleNames list of your *YourProject*.Build.cs file.
5. Set the Minimum SDK Version to no lower than 24 and the Target SDK Version to no lower than 31 when building an Android application.
6. Note that application minification (ProGuard/R8) is not currently supported.
7. All necessary gradle settings and project dependencies are specified in the RuStoreCore_UPL_Android.xml and RuStoreAppUpdate_UPL_Android.xml files.
8. To create an Update Manager, use the following code: URuStoreAppUpdateManager::Instance()->Init();
9. You can access all manager operations via Blueprints.
10. Remember to call the Dispose() method after finishing work with the object to free up memory and safely complete all requests sent.

As for integrating the RuStore AppUpdate SDK in Unity, this information is not provided in the documents.","To integrate the RuStore AppUpdate SDK in Unreal Engine, follow these steps:

### Unreal Engine Integration:

1. **Copy SDK Files:**
   - Copy the contents of the “Plugins” folder from the official RuStore repository on GitHub to the “Plugins” folder of your Unreal Engine project.

2. **Restart Unreal Engine:**
   - Restart Unreal Engine to ensure the plug-in files are recognized.

3. **Select Plug-ins:**
   - In the plug-in list (Edit → Plugins → Project → Mobile), select “RuStoreAppUpdate” and “RuStoreCore”.

4. **Update Dependencies:**
   - In the “YourProject.Build.cs” file, add the “RuStoreCore” and “RuStoreAppUpdate” modules to the PublicDependencyModuleNames list.

5. **Project Settings for Android:**
   - Set the Minimum SDK Version parameter to level 24 or later and the Target SDK Version parameter to 31 or later in the project settings (Edit → Project Settings → Android).

6. **Create Update Manager:**
   - Before calling library methods, create the update manager by calling `URuStoreAppUpdateManager::Instance()->Init();`.

7. **Check Initialization:**
   - To check if the library is initialized, use `URuStoreAppUpdateManager::Instance()->getIsInitialized();`.

8. **Check for Updates:**
   - Before starting the update installation, check if an update is available by calling the `GetAppUpdateInfo()` method.

9. **Complete Update:**
   - To start the update installation, call the `CompleteUpdate()` method.

### Unity Integration:

1. **Import SDK:**
   - Import the RuStore In-app updates SDK to your Unity project.

2. **Create Update Manager:**
   - Create an Update Manager before calling library methods.

3. **Check for Updates:**
   - Use the SDK to check for available updates.

4. **Download Updates:**
   - Download updates using the SDK.

5. **Install Updates:**
   - Install updates using the SDK.

6. **Handle Errors:**
   - Implement error handling for any issues that may arise during the update process.

Remember to meet the specified conditions for the SDK to work correctly on both Unreal Engine and Unity platforms."
What options are available in the CrashReportConfiguration.Builder for configuring crash reporting in Tracer?,"[' up-to-date information.\n\nNow the tracer configuration is done at the current tracer start-up instead of the next tracer start-up.\n\nTracer Modules\n\nCrash and ANR\n\nConnecting dependencies to your project In your <project>/<app-module>/build.gradle.\n\ndependencies {\n\nimplementation ""ru.ok.tracer:tracer-crash-report:0.2.7""\n\n}\n\nAlso, Tracer supports gathering and analysis of native crashes. If you want to gather crashes that occurred on the native code, connect the relevant dependency (see below).\n\ndependencies {\n\nimplementation ""ru.ok.tracer:tracer-crash-report-native:0.2.7""\n\n}\n\nWarning\n\nCurrently, this feature is under active development. Crash logs gathering functions, however, native crashes are displayed without stack trace and other details. Now you can gather and count them while displaying and categorization are being tweaked.\n\nFor a detailed description of the dependencies see “Quickstart”.\n\nCrashReportConfiguration and CrashFreeConfiguration description In your Application.kt.\n\nclass MyApplication : Application(), HasTracerConfiguration { override val tracerConfiguration: List<TracerConfiguration>\n\nget() = listOf(\n\nCrashReportConfiguration.build {\n\n// your options\n\n}, CrashFreeConfiguration.build {\n\n// your options\n\n176\n\n},\n\n)\n\n}\n\nBelow are the CrashReportConfiguration.Builder options:\n\nsetEnabled — enables/disables crash reporting. By default: enabled. setSendAnr — disables ANR sending. By default: enabled. setNativeEnabled — enables/disables native crash reporting. The default value depends on whether the tracer-crash-report-native dependency is connected. If the dependency is connected, then, reporting is by default enabled. If not, disabled. ⚠ You cannot enable native crash reporting without connecting the relevant dependency but you can disable reporting if the dependency is connected.\n\nBelow are the CrashReportConfiguration.Builder options that are deprecated or dangerous.\n\nsetHost — deprecated and will be removed in version 0.3.x. If you really need to\n\nchange the host, use CoreTracerConfiguration.setHost;\n\nsetSendLogs — deprecated and does nothing, will be removed in version 0.3.x; setCountCrashFreeUsers — deprecated and does nothing, will be removed in\n\nversion 0.3.x; use CrashFreeConfiguration.Builder.setEnabled instead;\n\nsetSendThreadsDump, setSendAsap, setMaxNonFatalExceptions — deprecated\n\nand do nothing, will be deleted in version 0.3.x.\n\nBelow are the CrashFreeConfiguration.Builder options.\n\nsetEnabled — enables/disables crash free users count. By default: disabled!\n\nBelow are the CrashFreeConfiguration.Builder options that are deprecated or dangerous.\n\nsetExperimentalMaxSessionsToUpload — how many sessions to gather before\n\nsending a batch. By default: 10. For testing purposes only!\n\nsetExperimentalMaxSessionTimeSpanToUpload — for how long to gather\n\nsessions before sending a batch. By default: 4 hours (in milliseconds). For testing purposes only!\n\nsetExperimentalUploadSessionsFromYesterday — send a batch if yesterday\'s (or\n\nearlier) sessions are detected. By default: enabled.\n\nTracerCrashReport description To send non-fatals the TracerCrashReport.report(throwable) method is used.\n\n// Log a non-fatal error. TracerCrashReport.report(NonFatalException(""I\'ll be ok soon""))\n\n177\n\nCrashes are grouped by common parts of a stack trace. By default, non-fatals, however, tweak this grouping approach.\n\nYou can gather all non-fatals in one group regardless of a stack trace using the report method with the issueKey parameter.\n\n// Log a non-fatal error with the ISSUE-001 key TracerCrashReport.report(NonFatalException(""What a terrible failure""), issueKey = ""ISSUE-001"")\n\nWarning\n\nCurrently, Tracer has a limit of 1 million events a day. That is why the excessive use of this method is not recommended.\n\nYou can also add additional info to an event.\n\nHeap Dumps\n\nConnecting dependencies to your project In your <project>/<app-m,odule>/build.gradle.\n\ndependencies {\n\nimplementation ""ru.ok.tracer:tracer-heap-dumps:0']","The options available in the CrashReportConfiguration.Builder for configuring crash reporting in Tracer include: setEnabled, setSendAnr, setNativeEnabled",simple,[{'source': 'docs_ai/rustore-en-developers-documentation (1).pdf'}],True,"The options available in the CrashReportConfiguration.Builder for configuring crash reporting in Tracer are:

1. setEnabled: enables/disables crash reporting. By default, it is enabled.
2. setSendAnr: disables ANR sending. By default, it is enabled.
3. setNativeEnabled: enables/disables native crash reporting. The default value depends on whether the tracer-crash-report-native dependency is connected. If the dependency is connected, then reporting is by default enabled. If not, it is disabled.

Additionally, there are deprecated or dangerous options in the CrashReportConfiguration.Builder:
1. setHost: deprecated and will be removed in version 0.3.x.
2. setSendLogs: deprecated and does nothing, will be removed in version 0.3.x.
3. setCountCrashFreeUsers: deprecated and does nothing, will be removed in version 0.3.x; use CrashFreeConfiguration.Builder.setEnabled instead.
4. setSendThreadsDump, setSendAsap, setMaxNonFatalExceptions: deprecated and do nothing, will be deleted in version 0.3.x.","The options available in the CrashReportConfiguration.Builder for configuring crash reporting in Tracer are:

1. setEnabled: enables or disables crash reporting. By default, it is enabled.
2. setSendAnr: disables ANR (Application Not Responding) sending. By default, it is enabled.
3. setNativeEnabled: enables or disables native crash reporting. The default value depends on whether the tracer-crash-report-native dependency is connected. If the dependency is connected, then native crash reporting is enabled by default. If not connected, it is disabled.

These options allow developers to customize and control the behavior of crash reporting in Tracer according to their needs."
